
RAYLID.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00000f5a  00000fee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f5a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000001  00800100  00800100  00000fee  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00000ff0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  000016bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000e0  00000000  00000000  00001748  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001f8b  00000000  00000000  00001828  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000364  00000000  00000000  000037b3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000633  00000000  00000000  00003b17  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006fc  00000000  00000000  0000414c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000008b4  00000000  00000000  00004848  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001d02  00000000  00000000  000050fc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ea e5       	ldi	r30, 0x5A	; 90
  7c:	ff e0       	ldi	r31, 0x0F	; 15
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a0 30       	cpi	r26, 0x00	; 0
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	11 e0       	ldi	r17, 0x01	; 1
  8c:	a0 e0       	ldi	r26, 0x00	; 0
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a1 30       	cpi	r26, 0x01	; 1
  96:	b1 07       	cpc	r27, r17
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 53 00 	call	0xa6	; 0xa6 <main>
  9e:	0c 94 ab 07 	jmp	0xf56	; 0xf56 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <main>:
#include "RSCG12864B.h"

int main(void)
{
	unsigned long n;
	RSCG12864B.begin();   //Initialize LCD
  a6:	c0 e0       	ldi	r28, 0x00	; 0
  a8:	d1 e0       	ldi	r29, 0x01	; 1
  aa:	ce 01       	movw	r24, r28
  ac:	0e 94 72 00 	call	0xe4	; 0xe4 <_ZN9RAYLIDLCD5beginEv>
	RSCG12864B.clear();   //Clear screen LCD
  b0:	ce 01       	movw	r24, r28
  b2:	0e 94 75 00 	call	0xea	; 0xea <_ZN9RAYLIDLCD5clearEv>
	RSCG12864B.brightness(0XFF); //Backlight brightness
  b6:	ce 01       	movw	r24, r28
  b8:	6f ef       	ldi	r22, 0xFF	; 255
  ba:	0e 94 93 00 	call	0x126	; 0x126 <_ZN9RAYLIDLCD10brightnessEh>
	n=0;
  be:	00 e0       	ldi	r16, 0x00	; 0
  c0:	10 e0       	ldi	r17, 0x00	; 0
  c2:	98 01       	movw	r18, r16
	while(1)
	{
		RSCG12864B.print_U32_8x16_xy(0,32,n++);
  c4:	68 01       	movw	r12, r16
  c6:	79 01       	movw	r14, r18
  c8:	08 94       	sec
  ca:	c1 1c       	adc	r12, r1
  cc:	d1 1c       	adc	r13, r1
  ce:	e1 1c       	adc	r14, r1
  d0:	f1 1c       	adc	r15, r1
  d2:	ce 01       	movw	r24, r28
  d4:	60 e0       	ldi	r22, 0x00	; 0
  d6:	40 e2       	ldi	r20, 0x20	; 32
  d8:	0e 94 43 05 	call	0xa86	; 0xa86 <_ZN9RAYLIDLCD17print_U32_8x16_xyEhhm>
  dc:	97 01       	movw	r18, r14
  de:	86 01       	movw	r16, r12
  e0:	f1 cf       	rjmp	.-30     	; 0xc4 <main+0x1e>

000000e2 <_ZN9RAYLIDLCDC1Ev>:
#include "RSCG12864B.h"

RAYLIDLCD::RAYLIDLCD()
{
	
}
  e2:	08 95       	ret

000000e4 <_ZN9RAYLIDLCD5beginEv>:

void RAYLIDLCD::RAYLIDLCD::begin()
{
	I2C_init();
  e4:	0e 94 26 07 	call	0xe4c	; 0xe4c <I2C_init>
}
  e8:	08 95       	ret

000000ea <_ZN9RAYLIDLCD5clearEv>:
*函数原型:clear()
*清屏
***********************************************************************/
void RAYLIDLCD::clear()
{
	I2C_start();
  ea:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
  ee:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x10);
  f2:	80 e1       	ldi	r24, 0x10	; 16
  f4:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
  f8:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
  fc:	08 95       	ret

000000fe <_ZN9RAYLIDLCD10display_onEv>:
*函数原型:display_on()
*打开显示，开机默认状态
***********************************************************************/
void RAYLIDLCD::display_on()
{
	I2C_start();
  fe:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 102:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x11);
 106:	81 e1       	ldi	r24, 0x11	; 17
 108:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 10c:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 110:	08 95       	ret

00000112 <_ZN9RAYLIDLCD11display_offEv>:
*函数原型:display_off()
*关闭显示
***********************************************************************/
void RAYLIDLCD::display_off()
{
	I2C_start();
 112:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 116:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x12);
 11a:	82 e1       	ldi	r24, 0x12	; 18
 11c:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 120:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 124:	08 95       	ret

00000126 <_ZN9RAYLIDLCD10brightnessEh>:
/***********************************************************************
*函数原型:brightness(U8 n)
*亮度设置
***********************************************************************/
void RAYLIDLCD::brightness(U8 n)
{
 126:	cf 93       	push	r28
 128:	c6 2f       	mov	r28, r22
	I2C_start();
 12a:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 12e:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x13);
 132:	83 e1       	ldi	r24, 0x13	; 19
 134:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(n);
 138:	8c 2f       	mov	r24, r28
 13a:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 13e:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 142:	cf 91       	pop	r28
 144:	08 95       	ret

00000146 <_ZN9RAYLIDLCD10draw_pixelEhh>:
/***********************************************************************
*函数原型:draw_pixel(U8 x,U8 y)
*绘制一个点
***********************************************************************/
void RAYLIDLCD::draw_pixel(U8 x,U8 y)
{
 146:	cf 93       	push	r28
 148:	df 93       	push	r29
 14a:	d6 2f       	mov	r29, r22
 14c:	c4 2f       	mov	r28, r20
	I2C_start();
 14e:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 152:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x30);
 156:	80 e3       	ldi	r24, 0x30	; 48
 158:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 15c:	8d 2f       	mov	r24, r29
 15e:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 162:	8c 2f       	mov	r24, r28
 164:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 168:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 16c:	df 91       	pop	r29
 16e:	cf 91       	pop	r28
 170:	08 95       	ret

00000172 <_ZN9RAYLIDLCD12delete_pixelEhh>:
/***********************************************************************
*函数原型:delete_pixel(U8 x,U8 y)
*删除点
***********************************************************************/
void RAYLIDLCD::delete_pixel(U8 x,U8 y)
{
 172:	cf 93       	push	r28
 174:	df 93       	push	r29
 176:	d6 2f       	mov	r29, r22
 178:	c4 2f       	mov	r28, r20
	I2C_start();
 17a:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 17e:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x31);
 182:	81 e3       	ldi	r24, 0x31	; 49
 184:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 188:	8d 2f       	mov	r24, r29
 18a:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 18e:	8c 2f       	mov	r24, r28
 190:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 194:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 198:	df 91       	pop	r29
 19a:	cf 91       	pop	r28
 19c:	08 95       	ret

0000019e <_ZN9RAYLIDLCD9draw_lineEhhhh>:
/***********************************************************************
*函数原型:draw_line(U8 x1,U8 y1,U8 x2,U8 y2)
*绘制直线
***********************************************************************/
void RAYLIDLCD::draw_line(U8 x1,U8 y1,U8 x2,U8 y2)
{
 19e:	0f 93       	push	r16
 1a0:	1f 93       	push	r17
 1a2:	cf 93       	push	r28
 1a4:	df 93       	push	r29
 1a6:	16 2f       	mov	r17, r22
 1a8:	d4 2f       	mov	r29, r20
 1aa:	c2 2f       	mov	r28, r18
	I2C_start();
 1ac:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 1b0:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x32);
 1b4:	82 e3       	ldi	r24, 0x32	; 50
 1b6:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x1);
 1ba:	81 2f       	mov	r24, r17
 1bc:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y1);
 1c0:	8d 2f       	mov	r24, r29
 1c2:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x2);
 1c6:	8c 2f       	mov	r24, r28
 1c8:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y2);
 1cc:	80 2f       	mov	r24, r16
 1ce:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 1d2:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 1d6:	df 91       	pop	r29
 1d8:	cf 91       	pop	r28
 1da:	1f 91       	pop	r17
 1dc:	0f 91       	pop	r16
 1de:	08 95       	ret

000001e0 <_ZN9RAYLIDLCD11delete_lineEhhhh>:
/***********************************************************************
*函数原型:delete_line(U8 x1,U8 y1,U8 x2,U8 y2)
*删除一条直线
***********************************************************************/
void RAYLIDLCD::delete_line(U8 x1,U8 y1,U8 x2,U8 y2)
{
 1e0:	0f 93       	push	r16
 1e2:	1f 93       	push	r17
 1e4:	cf 93       	push	r28
 1e6:	df 93       	push	r29
 1e8:	16 2f       	mov	r17, r22
 1ea:	d4 2f       	mov	r29, r20
 1ec:	c2 2f       	mov	r28, r18
	I2C_start();
 1ee:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 1f2:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x33);
 1f6:	83 e3       	ldi	r24, 0x33	; 51
 1f8:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x1);
 1fc:	81 2f       	mov	r24, r17
 1fe:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y1);
 202:	8d 2f       	mov	r24, r29
 204:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x2);
 208:	8c 2f       	mov	r24, r28
 20a:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y2);
 20e:	80 2f       	mov	r24, r16
 210:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 214:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 218:	df 91       	pop	r29
 21a:	cf 91       	pop	r28
 21c:	1f 91       	pop	r17
 21e:	0f 91       	pop	r16
 220:	08 95       	ret

00000222 <_ZN9RAYLIDLCD14draw_rectangleEhhhh>:
/***********************************************************************
*函数原型:draw_rectangle(U8 x1,U8 y1,U8 x2,U8 y2)
*绘制矩形
***********************************************************************/
void RAYLIDLCD::draw_rectangle(U8 x1,U8 y1,U8 x2,U8 y2)
{
 222:	0f 93       	push	r16
 224:	1f 93       	push	r17
 226:	cf 93       	push	r28
 228:	df 93       	push	r29
 22a:	16 2f       	mov	r17, r22
 22c:	d4 2f       	mov	r29, r20
 22e:	c2 2f       	mov	r28, r18
	I2C_start();
 230:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 234:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x34);
 238:	84 e3       	ldi	r24, 0x34	; 52
 23a:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x1);
 23e:	81 2f       	mov	r24, r17
 240:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y1);
 244:	8d 2f       	mov	r24, r29
 246:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x2);
 24a:	8c 2f       	mov	r24, r28
 24c:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y2);
 250:	80 2f       	mov	r24, r16
 252:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 256:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 25a:	df 91       	pop	r29
 25c:	cf 91       	pop	r28
 25e:	1f 91       	pop	r17
 260:	0f 91       	pop	r16
 262:	08 95       	ret

00000264 <_ZN9RAYLIDLCD16delete_rectangleEhhhh>:
/***********************************************************************
*函数原型:delete_rectangle(U8 x1,U8 y1,U8 x2,U8 y2)
*删除矩形
***********************************************************************/
void RAYLIDLCD::delete_rectangle(U8 x1,U8 y1,U8 x2,U8 y2)
{
 264:	0f 93       	push	r16
 266:	1f 93       	push	r17
 268:	cf 93       	push	r28
 26a:	df 93       	push	r29
 26c:	16 2f       	mov	r17, r22
 26e:	d4 2f       	mov	r29, r20
 270:	c2 2f       	mov	r28, r18
	I2C_start();
 272:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 276:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x35);
 27a:	85 e3       	ldi	r24, 0x35	; 53
 27c:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x1);
 280:	81 2f       	mov	r24, r17
 282:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y1);
 286:	8d 2f       	mov	r24, r29
 288:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x2);
 28c:	8c 2f       	mov	r24, r28
 28e:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y2);
 292:	80 2f       	mov	r24, r16
 294:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 298:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 29c:	df 91       	pop	r29
 29e:	cf 91       	pop	r28
 2a0:	1f 91       	pop	r17
 2a2:	0f 91       	pop	r16
 2a4:	08 95       	ret

000002a6 <_ZN9RAYLIDLCD19draw_fill_rectangleEhhhh>:
/***********************************************************************
*函数原型:draw_fill_rectangle(U8 x1,U8 y1,U8 x2,U8 y2)
*绘制填充矩形
***********************************************************************/
void RAYLIDLCD::draw_fill_rectangle(U8 x1,U8 y1,U8 x2,U8 y2)
{
 2a6:	0f 93       	push	r16
 2a8:	1f 93       	push	r17
 2aa:	cf 93       	push	r28
 2ac:	df 93       	push	r29
 2ae:	16 2f       	mov	r17, r22
 2b0:	d4 2f       	mov	r29, r20
 2b2:	c2 2f       	mov	r28, r18
	I2C_start();
 2b4:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 2b8:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x36);
 2bc:	86 e3       	ldi	r24, 0x36	; 54
 2be:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x1);
 2c2:	81 2f       	mov	r24, r17
 2c4:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y1);
 2c8:	8d 2f       	mov	r24, r29
 2ca:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x2);
 2ce:	8c 2f       	mov	r24, r28
 2d0:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y2);
 2d4:	80 2f       	mov	r24, r16
 2d6:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 2da:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 2de:	df 91       	pop	r29
 2e0:	cf 91       	pop	r28
 2e2:	1f 91       	pop	r17
 2e4:	0f 91       	pop	r16
 2e6:	08 95       	ret

000002e8 <_ZN9RAYLIDLCD21delete_fill_rectangleEhhhh>:
/***********************************************************************
*函数原型:delete_fill_rectangle(U8 x1,U8 y1,U8 x2,U8 y2)
*删除填充矩形
***********************************************************************/
void RAYLIDLCD::delete_fill_rectangle(U8 x1,U8 y1,U8 x2,U8 y2)
{
 2e8:	0f 93       	push	r16
 2ea:	1f 93       	push	r17
 2ec:	cf 93       	push	r28
 2ee:	df 93       	push	r29
 2f0:	16 2f       	mov	r17, r22
 2f2:	d4 2f       	mov	r29, r20
 2f4:	c2 2f       	mov	r28, r18
	I2C_start();
 2f6:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 2fa:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x37);
 2fe:	87 e3       	ldi	r24, 0x37	; 55
 300:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x1);
 304:	81 2f       	mov	r24, r17
 306:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y1);
 30a:	8d 2f       	mov	r24, r29
 30c:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x2);
 310:	8c 2f       	mov	r24, r28
 312:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y2);
 316:	80 2f       	mov	r24, r16
 318:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 31c:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 320:	df 91       	pop	r29
 322:	cf 91       	pop	r28
 324:	1f 91       	pop	r17
 326:	0f 91       	pop	r16
 328:	08 95       	ret

0000032a <_ZN9RAYLIDLCD11draw_circleEhhh>:
/***********************************************************************
*函数原型:draw_circle(U8 x,U8 y,U8 r)
*在制定位置绘制一个圆?
***********************************************************************/
void RAYLIDLCD::draw_circle(U8 x,U8 y,U8 r)
{
 32a:	1f 93       	push	r17
 32c:	cf 93       	push	r28
 32e:	df 93       	push	r29
 330:	16 2f       	mov	r17, r22
 332:	d4 2f       	mov	r29, r20
 334:	c2 2f       	mov	r28, r18
	I2C_start();
 336:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 33a:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x38);
 33e:	88 e3       	ldi	r24, 0x38	; 56
 340:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 344:	81 2f       	mov	r24, r17
 346:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 34a:	8d 2f       	mov	r24, r29
 34c:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(r);
 350:	8c 2f       	mov	r24, r28
 352:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 356:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 35a:	df 91       	pop	r29
 35c:	cf 91       	pop	r28
 35e:	1f 91       	pop	r17
 360:	08 95       	ret

00000362 <_ZN9RAYLIDLCD13delete_circleEhhh>:
/***********************************************************************
*函数原型:delete_circle(U8 x,U8 y,U8 r)
*删除圆
***********************************************************************/
void RAYLIDLCD::delete_circle(U8 x,U8 y,U8 r)
{
 362:	1f 93       	push	r17
 364:	cf 93       	push	r28
 366:	df 93       	push	r29
 368:	16 2f       	mov	r17, r22
 36a:	d4 2f       	mov	r29, r20
 36c:	c2 2f       	mov	r28, r18
	I2C_start();
 36e:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 372:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x39);
 376:	89 e3       	ldi	r24, 0x39	; 57
 378:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 37c:	81 2f       	mov	r24, r17
 37e:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 382:	8d 2f       	mov	r24, r29
 384:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(r);
 388:	8c 2f       	mov	r24, r28
 38a:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 38e:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 392:	df 91       	pop	r29
 394:	cf 91       	pop	r28
 396:	1f 91       	pop	r17
 398:	08 95       	ret

0000039a <_ZN9RAYLIDLCD16draw_fill_circleEhhh>:
/***********************************************************************
*函数原型:draw_fill_rectangle(U8 x1,U8 y1,U8 x2,U8 y2)
*在制定位置绘制一个填充圆?
***********************************************************************/
void RAYLIDLCD::draw_fill_circle(U8 x,U8 y,U8 r)
{
 39a:	1f 93       	push	r17
 39c:	cf 93       	push	r28
 39e:	df 93       	push	r29
 3a0:	16 2f       	mov	r17, r22
 3a2:	d4 2f       	mov	r29, r20
 3a4:	c2 2f       	mov	r28, r18
	I2C_start();
 3a6:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 3aa:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x3A);
 3ae:	8a e3       	ldi	r24, 0x3A	; 58
 3b0:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 3b4:	81 2f       	mov	r24, r17
 3b6:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 3ba:	8d 2f       	mov	r24, r29
 3bc:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(r);
 3c0:	8c 2f       	mov	r24, r28
 3c2:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 3c6:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 3ca:	df 91       	pop	r29
 3cc:	cf 91       	pop	r28
 3ce:	1f 91       	pop	r17
 3d0:	08 95       	ret

000003d2 <_ZN9RAYLIDLCD18delete_fill_circleEhhh>:
/***********************************************************************
*函数原型:delete_fill_circle(U8 x,U8 y,U8 r)
*在制定位置删除一个填充圆
***********************************************************************/
void RAYLIDLCD::delete_fill_circle(U8 x,U8 y,U8 r)
{
 3d2:	1f 93       	push	r17
 3d4:	cf 93       	push	r28
 3d6:	df 93       	push	r29
 3d8:	16 2f       	mov	r17, r22
 3da:	d4 2f       	mov	r29, r20
 3dc:	c2 2f       	mov	r28, r18
	I2C_start();
 3de:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 3e2:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x3B);
 3e6:	8b e3       	ldi	r24, 0x3B	; 59
 3e8:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 3ec:	81 2f       	mov	r24, r17
 3ee:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 3f2:	8d 2f       	mov	r24, r29
 3f4:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(r);
 3f8:	8c 2f       	mov	r24, r28
 3fa:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 3fe:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 402:	df 91       	pop	r29
 404:	cf 91       	pop	r28
 406:	1f 91       	pop	r17
 408:	08 95       	ret

0000040a <_ZN9RAYLIDLCD14inversely_areaEhhhh>:
/***********************************************************************
*函数原型:inversely_area(U8 x1,U8 y1,U8 x2,U8 y2)
*指定区域反白显示
***********************************************************************/
void RAYLIDLCD::inversely_area(U8 x1,U8 y1,U8 x2,U8 y2)
{
 40a:	0f 93       	push	r16
 40c:	1f 93       	push	r17
 40e:	cf 93       	push	r28
 410:	df 93       	push	r29
 412:	16 2f       	mov	r17, r22
 414:	d4 2f       	mov	r29, r20
 416:	c2 2f       	mov	r28, r18
	I2C_start();
 418:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 41c:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x38);
 420:	88 e3       	ldi	r24, 0x38	; 56
 422:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x1);
 426:	81 2f       	mov	r24, r17
 428:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y1);
 42c:	8d 2f       	mov	r24, r29
 42e:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x2);
 432:	8c 2f       	mov	r24, r28
 434:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y2);
 438:	80 2f       	mov	r24, r16
 43a:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 43e:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 442:	df 91       	pop	r29
 444:	cf 91       	pop	r28
 446:	1f 91       	pop	r17
 448:	0f 91       	pop	r16
 44a:	08 95       	ret

0000044c <_ZN9RAYLIDLCD11display_bmpEj>:
/***********************************************************************
*函数原型:display_bmp(U16 n)
*整张显示预存图片
***********************************************************************/
void RAYLIDLCD::display_bmp(U16 n)
{
 44c:	cf 93       	push	r28
 44e:	df 93       	push	r29
 450:	c6 2f       	mov	r28, r22
 452:	d7 2f       	mov	r29, r23
	I2C_start();
 454:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 458:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x3D);
 45c:	8d e3       	ldi	r24, 0x3D	; 61
 45e:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(n>>8);
 462:	8d 2f       	mov	r24, r29
 464:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(n);
 468:	8c 2f       	mov	r24, r28
 46a:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 46e:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 472:	df 91       	pop	r29
 474:	cf 91       	pop	r28
 476:	08 95       	ret

00000478 <_ZN9RAYLIDLCD17display_bmp_blockEjhhhhhh>:
/***********************************************************************
*函数原型:display_bmp_block(U16 n,U8 px,U8 py,U8 xU8 y,U8 w,U8 h)
*块显示预存图片
***********************************************************************/
void RAYLIDLCD::display_bmp_block(U16 n,U8 px,U8 py,U8 x,U8 y,U8 w,U8 h)
{
 478:	af 92       	push	r10
 47a:	cf 92       	push	r12
 47c:	ef 92       	push	r14
 47e:	ff 92       	push	r15
 480:	0f 93       	push	r16
 482:	1f 93       	push	r17
 484:	cf 93       	push	r28
 486:	df 93       	push	r29
 488:	d6 2f       	mov	r29, r22
 48a:	c7 2f       	mov	r28, r23
 48c:	14 2f       	mov	r17, r20
 48e:	f2 2e       	mov	r15, r18
	I2C_start();
 490:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 494:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x3E);
 498:	8e e3       	ldi	r24, 0x3E	; 62
 49a:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(n>>8);
 49e:	8c 2f       	mov	r24, r28
 4a0:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(n);
 4a4:	8d 2f       	mov	r24, r29
 4a6:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 4aa:	80 2f       	mov	r24, r16
 4ac:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 4b0:	8e 2d       	mov	r24, r14
 4b2:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(px);
 4b6:	81 2f       	mov	r24, r17
 4b8:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(py);
 4bc:	8f 2d       	mov	r24, r15
 4be:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(w);
 4c2:	8c 2d       	mov	r24, r12
 4c4:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(h);
 4c8:	8a 2d       	mov	r24, r10
 4ca:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 4ce:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 4d2:	df 91       	pop	r29
 4d4:	cf 91       	pop	r28
 4d6:	1f 91       	pop	r17
 4d8:	0f 91       	pop	r16
 4da:	ff 90       	pop	r15
 4dc:	ef 90       	pop	r14
 4de:	cf 90       	pop	r12
 4e0:	af 90       	pop	r10
 4e2:	08 95       	ret

000004e4 <_ZN9RAYLIDLCD6cursorEhh>:
*函数原型:cursor(U8 x,U8 y)
*设置字符显示位置
参数：x:0~127  y:0~63
***********************************************************************/
void RAYLIDLCD::cursor(U8 x,U8 y)
{
 4e4:	cf 93       	push	r28
 4e6:	df 93       	push	r29
 4e8:	d6 2f       	mov	r29, r22
 4ea:	c4 2f       	mov	r28, r20
	I2C_start();
 4ec:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 4f0:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x20);
 4f4:	80 e2       	ldi	r24, 0x20	; 32
 4f6:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 4fa:	8d 2f       	mov	r24, r29
 4fc:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 500:	8c 2f       	mov	r24, r28
 502:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 506:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 50a:	df 91       	pop	r29
 50c:	cf 91       	pop	r28
 50e:	08 95       	ret

00000510 <_ZN9RAYLIDLCD7spacingEhh>:
*函数原型:spacing(U8 xs,U8 ys)
*设置字符间距
参数：xs:0~127  ys:0~63
***********************************************************************/
void RAYLIDLCD::spacing(U8 xs,U8 ys)
{
 510:	cf 93       	push	r28
 512:	df 93       	push	r29
 514:	d6 2f       	mov	r29, r22
 516:	c4 2f       	mov	r28, r20
	I2C_start();
 518:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 51c:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x21);
 520:	81 e2       	ldi	r24, 0x21	; 33
 522:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(xs);
 526:	8d 2f       	mov	r24, r29
 528:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(ys);
 52c:	8c 2f       	mov	r24, r28
 52e:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 532:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 536:	df 91       	pop	r29
 538:	cf 91       	pop	r28
 53a:	08 95       	ret

0000053c <_ZN9RAYLIDLCD14font_revers_onEv>:
*函数原型:font_revers_on()
*字符反显模式开启
***********************************************************************/
void  RAYLIDLCD::font_revers_on()
{
	I2C_start();
 53c:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 540:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x23);
 544:	83 e2       	ldi	r24, 0x23	; 35
 546:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 54a:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 54e:	08 95       	ret

00000550 <_ZN9RAYLIDLCD15font_revers_offEv>:
*函数原型:font_revers_ff()
*字符反显模式关闭
***********************************************************************/
void  RAYLIDLCD::font_revers_off()
{
	I2C_start();
 550:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 554:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x22);
 558:	82 e2       	ldi	r24, 0x22	; 34
 55a:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 55e:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 562:	08 95       	ret

00000564 <_ZN9RAYLIDLCD13print_U32_5x7Em>:
/***********************************************************************
*函数原型:print_U32_5x7(U32 n)
*在当前位置显示长整型变量n
***********************************************************************/
void RAYLIDLCD::print_U32_5x7(U32 n)
{
 564:	4f 92       	push	r4
 566:	5f 92       	push	r5
 568:	6f 92       	push	r6
 56a:	7f 92       	push	r7
 56c:	8f 92       	push	r8
 56e:	9f 92       	push	r9
 570:	af 92       	push	r10
 572:	bf 92       	push	r11
 574:	cf 92       	push	r12
 576:	df 92       	push	r13
 578:	ef 92       	push	r14
 57a:	ff 92       	push	r15
 57c:	0f 93       	push	r16
 57e:	1f 93       	push	r17
 580:	cf 93       	push	r28
 582:	df 93       	push	r29
 584:	2a 01       	movw	r4, r20
 586:	3b 01       	movw	r6, r22
	U32 i,temp;
	U8 t=0;
	I2C_start();
 588:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 58c:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x24);
 590:	84 e2       	ldi	r24, 0x24	; 36
 592:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	if(n==0)
 596:	41 14       	cp	r4, r1
 598:	51 04       	cpc	r5, r1
 59a:	61 04       	cpc	r6, r1
 59c:	71 04       	cpc	r7, r1
 59e:	21 f4       	brne	.+8      	; 0x5a8 <_ZN9RAYLIDLCD13print_U32_5x7Em+0x44>
	{
		I2C_send(0x30);
 5a0:	80 e3       	ldi	r24, 0x30	; 48
 5a2:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
 5a6:	47 c0       	rjmp	.+142    	; 0x636 <_ZN9RAYLIDLCD13print_U32_5x7Em+0xd2>
	U32 i,temp;
	U8 t=0;
	I2C_start();
	I2C_to_write();
	I2C_send(0x24);
	if(n==0)
 5a8:	ca e0       	ldi	r28, 0x0A	; 10
 5aa:	d0 e0       	ldi	r29, 0x00	; 0
 5ac:	10 e0       	ldi	r17, 0x00	; 0
 5ae:	0f 2e       	mov	r0, r31
 5b0:	f0 e0       	ldi	r31, 0x00	; 0
 5b2:	cf 2e       	mov	r12, r31
 5b4:	fa ec       	ldi	r31, 0xCA	; 202
 5b6:	df 2e       	mov	r13, r31
 5b8:	fa e9       	ldi	r31, 0x9A	; 154
 5ba:	ef 2e       	mov	r14, r31
 5bc:	fb e3       	ldi	r31, 0x3B	; 59
 5be:	ff 2e       	mov	r15, r31
 5c0:	f0 2d       	mov	r31, r0
				I2C_send(temp%10+0x30);
				t=1;
			}
			else if(t==1)
			{
				I2C_send(temp%10+0x30);
 5c2:	0f 2e       	mov	r0, r31
 5c4:	fa e0       	ldi	r31, 0x0A	; 10
 5c6:	8f 2e       	mov	r8, r31
 5c8:	f0 e0       	ldi	r31, 0x00	; 0
 5ca:	9f 2e       	mov	r9, r31
 5cc:	f0 e0       	ldi	r31, 0x00	; 0
 5ce:	af 2e       	mov	r10, r31
 5d0:	f0 e0       	ldi	r31, 0x00	; 0
 5d2:	bf 2e       	mov	r11, r31
 5d4:	f0 2d       	mov	r31, r0
		{
			temp=n/i;
			if(t==0&&temp)
			{
				I2C_send(temp%10+0x30);
				t=1;
 5d6:	01 e0       	ldi	r16, 0x01	; 1
	}
	else
	{
		for(i=1000000000;i>=1;i=i/10)
		{
			temp=n/i;
 5d8:	c3 01       	movw	r24, r6
 5da:	b2 01       	movw	r22, r4
 5dc:	a7 01       	movw	r20, r14
 5de:	96 01       	movw	r18, r12
 5e0:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
			if(t==0&&temp)
 5e4:	11 23       	and	r17, r17
 5e6:	89 f4       	brne	.+34     	; 0x60a <_ZN9RAYLIDLCD13print_U32_5x7Em+0xa6>
 5e8:	21 15       	cp	r18, r1
 5ea:	31 05       	cpc	r19, r1
 5ec:	41 05       	cpc	r20, r1
 5ee:	51 05       	cpc	r21, r1
 5f0:	61 f0       	breq	.+24     	; 0x60a <_ZN9RAYLIDLCD13print_U32_5x7Em+0xa6>
			{
				I2C_send(temp%10+0x30);
 5f2:	ca 01       	movw	r24, r20
 5f4:	b9 01       	movw	r22, r18
 5f6:	a5 01       	movw	r20, r10
 5f8:	94 01       	movw	r18, r8
 5fa:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 5fe:	86 2f       	mov	r24, r22
 600:	80 5d       	subi	r24, 0xD0	; 208
 602:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
				t=1;
 606:	10 2f       	mov	r17, r16
 608:	0c c0       	rjmp	.+24     	; 0x622 <_ZN9RAYLIDLCD13print_U32_5x7Em+0xbe>
			}
			else if(t==1)
 60a:	11 30       	cpi	r17, 0x01	; 1
 60c:	51 f4       	brne	.+20     	; 0x622 <_ZN9RAYLIDLCD13print_U32_5x7Em+0xbe>
			{
				I2C_send(temp%10+0x30);
 60e:	ca 01       	movw	r24, r20
 610:	b9 01       	movw	r22, r18
 612:	a5 01       	movw	r20, r10
 614:	94 01       	movw	r18, r8
 616:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 61a:	86 2f       	mov	r24, r22
 61c:	80 5d       	subi	r24, 0xD0	; 208
 61e:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	{
		I2C_send(0x30);
	}
	else
	{
		for(i=1000000000;i>=1;i=i/10)
 622:	c7 01       	movw	r24, r14
 624:	b6 01       	movw	r22, r12
 626:	a5 01       	movw	r20, r10
 628:	94 01       	movw	r18, r8
 62a:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 62e:	69 01       	movw	r12, r18
 630:	7a 01       	movw	r14, r20
 632:	21 97       	sbiw	r28, 0x01	; 1
 634:	89 f6       	brne	.-94     	; 0x5d8 <_ZN9RAYLIDLCD13print_U32_5x7Em+0x74>
			{
				I2C_send(temp%10+0x30);
			}
		}
	}
	I2C_send(0x00);
 636:	80 e0       	ldi	r24, 0x00	; 0
 638:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 63c:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 640:	df 91       	pop	r29
 642:	cf 91       	pop	r28
 644:	1f 91       	pop	r17
 646:	0f 91       	pop	r16
 648:	ff 90       	pop	r15
 64a:	ef 90       	pop	r14
 64c:	df 90       	pop	r13
 64e:	cf 90       	pop	r12
 650:	bf 90       	pop	r11
 652:	af 90       	pop	r10
 654:	9f 90       	pop	r9
 656:	8f 90       	pop	r8
 658:	7f 90       	pop	r7
 65a:	6f 90       	pop	r6
 65c:	5f 90       	pop	r5
 65e:	4f 90       	pop	r4
 660:	08 95       	ret

00000662 <_ZN9RAYLIDLCD14print_U32_6x12Em>:
*函数原型:print_U32_6x12(U32 n)
*在当前位置显示长整型变量n
***********************************************************************/

void RAYLIDLCD::print_U32_6x12(U32 n)
{
 662:	4f 92       	push	r4
 664:	5f 92       	push	r5
 666:	6f 92       	push	r6
 668:	7f 92       	push	r7
 66a:	8f 92       	push	r8
 66c:	9f 92       	push	r9
 66e:	af 92       	push	r10
 670:	bf 92       	push	r11
 672:	cf 92       	push	r12
 674:	df 92       	push	r13
 676:	ef 92       	push	r14
 678:	ff 92       	push	r15
 67a:	0f 93       	push	r16
 67c:	1f 93       	push	r17
 67e:	cf 93       	push	r28
 680:	df 93       	push	r29
 682:	2a 01       	movw	r4, r20
 684:	3b 01       	movw	r6, r22
	U32 i,temp;
	U8 t=0;
	I2C_start();
 686:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 68a:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x25);
 68e:	85 e2       	ldi	r24, 0x25	; 37
 690:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	if(n==0)
 694:	41 14       	cp	r4, r1
 696:	51 04       	cpc	r5, r1
 698:	61 04       	cpc	r6, r1
 69a:	71 04       	cpc	r7, r1
 69c:	21 f4       	brne	.+8      	; 0x6a6 <_ZN9RAYLIDLCD14print_U32_6x12Em+0x44>
	{
		I2C_send(0x30);
 69e:	80 e3       	ldi	r24, 0x30	; 48
 6a0:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
 6a4:	47 c0       	rjmp	.+142    	; 0x734 <_ZN9RAYLIDLCD14print_U32_6x12Em+0xd2>
	U32 i,temp;
	U8 t=0;
	I2C_start();
	I2C_to_write();
	I2C_send(0x25);
	if(n==0)
 6a6:	ca e0       	ldi	r28, 0x0A	; 10
 6a8:	d0 e0       	ldi	r29, 0x00	; 0
 6aa:	10 e0       	ldi	r17, 0x00	; 0
 6ac:	0f 2e       	mov	r0, r31
 6ae:	f0 e0       	ldi	r31, 0x00	; 0
 6b0:	cf 2e       	mov	r12, r31
 6b2:	fa ec       	ldi	r31, 0xCA	; 202
 6b4:	df 2e       	mov	r13, r31
 6b6:	fa e9       	ldi	r31, 0x9A	; 154
 6b8:	ef 2e       	mov	r14, r31
 6ba:	fb e3       	ldi	r31, 0x3B	; 59
 6bc:	ff 2e       	mov	r15, r31
 6be:	f0 2d       	mov	r31, r0
				I2C_send(temp%10+0x30);
				t=1;
			}
			else if(t==1)
			{
				I2C_send(temp%10+0x30);
 6c0:	0f 2e       	mov	r0, r31
 6c2:	fa e0       	ldi	r31, 0x0A	; 10
 6c4:	8f 2e       	mov	r8, r31
 6c6:	f0 e0       	ldi	r31, 0x00	; 0
 6c8:	9f 2e       	mov	r9, r31
 6ca:	f0 e0       	ldi	r31, 0x00	; 0
 6cc:	af 2e       	mov	r10, r31
 6ce:	f0 e0       	ldi	r31, 0x00	; 0
 6d0:	bf 2e       	mov	r11, r31
 6d2:	f0 2d       	mov	r31, r0
		{
			temp=n/i;
			if(t==0&&temp)
			{
				I2C_send(temp%10+0x30);
				t=1;
 6d4:	01 e0       	ldi	r16, 0x01	; 1
	}
	else
	{
		for(i=1000000000;i>=1;i=i/10)
		{
			temp=n/i;
 6d6:	c3 01       	movw	r24, r6
 6d8:	b2 01       	movw	r22, r4
 6da:	a7 01       	movw	r20, r14
 6dc:	96 01       	movw	r18, r12
 6de:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
			if(t==0&&temp)
 6e2:	11 23       	and	r17, r17
 6e4:	89 f4       	brne	.+34     	; 0x708 <_ZN9RAYLIDLCD14print_U32_6x12Em+0xa6>
 6e6:	21 15       	cp	r18, r1
 6e8:	31 05       	cpc	r19, r1
 6ea:	41 05       	cpc	r20, r1
 6ec:	51 05       	cpc	r21, r1
 6ee:	61 f0       	breq	.+24     	; 0x708 <_ZN9RAYLIDLCD14print_U32_6x12Em+0xa6>
			{
				I2C_send(temp%10+0x30);
 6f0:	ca 01       	movw	r24, r20
 6f2:	b9 01       	movw	r22, r18
 6f4:	a5 01       	movw	r20, r10
 6f6:	94 01       	movw	r18, r8
 6f8:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 6fc:	86 2f       	mov	r24, r22
 6fe:	80 5d       	subi	r24, 0xD0	; 208
 700:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
				t=1;
 704:	10 2f       	mov	r17, r16
 706:	0c c0       	rjmp	.+24     	; 0x720 <_ZN9RAYLIDLCD14print_U32_6x12Em+0xbe>
			}
			else if(t==1)
 708:	11 30       	cpi	r17, 0x01	; 1
 70a:	51 f4       	brne	.+20     	; 0x720 <_ZN9RAYLIDLCD14print_U32_6x12Em+0xbe>
			{
				I2C_send(temp%10+0x30);
 70c:	ca 01       	movw	r24, r20
 70e:	b9 01       	movw	r22, r18
 710:	a5 01       	movw	r20, r10
 712:	94 01       	movw	r18, r8
 714:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 718:	86 2f       	mov	r24, r22
 71a:	80 5d       	subi	r24, 0xD0	; 208
 71c:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	{
		I2C_send(0x30);
	}
	else
	{
		for(i=1000000000;i>=1;i=i/10)
 720:	c7 01       	movw	r24, r14
 722:	b6 01       	movw	r22, r12
 724:	a5 01       	movw	r20, r10
 726:	94 01       	movw	r18, r8
 728:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 72c:	69 01       	movw	r12, r18
 72e:	7a 01       	movw	r14, r20
 730:	21 97       	sbiw	r28, 0x01	; 1
 732:	89 f6       	brne	.-94     	; 0x6d6 <_ZN9RAYLIDLCD14print_U32_6x12Em+0x74>
			{
				I2C_send(temp%10+0x30);
			}
		}
	}
	I2C_send(0x00);
 734:	80 e0       	ldi	r24, 0x00	; 0
 736:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 73a:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 73e:	df 91       	pop	r29
 740:	cf 91       	pop	r28
 742:	1f 91       	pop	r17
 744:	0f 91       	pop	r16
 746:	ff 90       	pop	r15
 748:	ef 90       	pop	r14
 74a:	df 90       	pop	r13
 74c:	cf 90       	pop	r12
 74e:	bf 90       	pop	r11
 750:	af 90       	pop	r10
 752:	9f 90       	pop	r9
 754:	8f 90       	pop	r8
 756:	7f 90       	pop	r7
 758:	6f 90       	pop	r6
 75a:	5f 90       	pop	r5
 75c:	4f 90       	pop	r4
 75e:	08 95       	ret

00000760 <_ZN9RAYLIDLCD14print_U32_8x16Em>:
/***********************************************************************
*函数原型:print_U32_8x16(U32 n)
*在当前位置显示长整型变量n
***********************************************************************/
void RAYLIDLCD::print_U32_8x16(U32 n)
{
 760:	4f 92       	push	r4
 762:	5f 92       	push	r5
 764:	6f 92       	push	r6
 766:	7f 92       	push	r7
 768:	8f 92       	push	r8
 76a:	9f 92       	push	r9
 76c:	af 92       	push	r10
 76e:	bf 92       	push	r11
 770:	cf 92       	push	r12
 772:	df 92       	push	r13
 774:	ef 92       	push	r14
 776:	ff 92       	push	r15
 778:	0f 93       	push	r16
 77a:	1f 93       	push	r17
 77c:	cf 93       	push	r28
 77e:	df 93       	push	r29
 780:	2a 01       	movw	r4, r20
 782:	3b 01       	movw	r6, r22
	U32 i,temp;
	U8 t=0;
	I2C_start();
 784:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 788:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x26);
 78c:	86 e2       	ldi	r24, 0x26	; 38
 78e:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	if(n==0)
 792:	41 14       	cp	r4, r1
 794:	51 04       	cpc	r5, r1
 796:	61 04       	cpc	r6, r1
 798:	71 04       	cpc	r7, r1
 79a:	21 f4       	brne	.+8      	; 0x7a4 <_ZN9RAYLIDLCD14print_U32_8x16Em+0x44>
	{
		I2C_send(0x30);
 79c:	80 e3       	ldi	r24, 0x30	; 48
 79e:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
 7a2:	47 c0       	rjmp	.+142    	; 0x832 <_ZN9RAYLIDLCD14print_U32_8x16Em+0xd2>
	U32 i,temp;
	U8 t=0;
	I2C_start();
	I2C_to_write();
	I2C_send(0x26);
	if(n==0)
 7a4:	ca e0       	ldi	r28, 0x0A	; 10
 7a6:	d0 e0       	ldi	r29, 0x00	; 0
 7a8:	10 e0       	ldi	r17, 0x00	; 0
 7aa:	0f 2e       	mov	r0, r31
 7ac:	f0 e0       	ldi	r31, 0x00	; 0
 7ae:	cf 2e       	mov	r12, r31
 7b0:	fa ec       	ldi	r31, 0xCA	; 202
 7b2:	df 2e       	mov	r13, r31
 7b4:	fa e9       	ldi	r31, 0x9A	; 154
 7b6:	ef 2e       	mov	r14, r31
 7b8:	fb e3       	ldi	r31, 0x3B	; 59
 7ba:	ff 2e       	mov	r15, r31
 7bc:	f0 2d       	mov	r31, r0
				I2C_send(temp%10+0x30);
				t=1;
			}
			else if(t==1)
			{
				I2C_send(temp%10+0x30);
 7be:	0f 2e       	mov	r0, r31
 7c0:	fa e0       	ldi	r31, 0x0A	; 10
 7c2:	8f 2e       	mov	r8, r31
 7c4:	f0 e0       	ldi	r31, 0x00	; 0
 7c6:	9f 2e       	mov	r9, r31
 7c8:	f0 e0       	ldi	r31, 0x00	; 0
 7ca:	af 2e       	mov	r10, r31
 7cc:	f0 e0       	ldi	r31, 0x00	; 0
 7ce:	bf 2e       	mov	r11, r31
 7d0:	f0 2d       	mov	r31, r0
		{
			temp=n/i;
			if(t==0&&temp)
			{
				I2C_send(temp%10+0x30);
				t=1;
 7d2:	01 e0       	ldi	r16, 0x01	; 1
	}
	else
	{
		for(i=1000000000;i>=1;i=i/10)
		{
			temp=n/i;
 7d4:	c3 01       	movw	r24, r6
 7d6:	b2 01       	movw	r22, r4
 7d8:	a7 01       	movw	r20, r14
 7da:	96 01       	movw	r18, r12
 7dc:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
			if(t==0&&temp)
 7e0:	11 23       	and	r17, r17
 7e2:	89 f4       	brne	.+34     	; 0x806 <_ZN9RAYLIDLCD14print_U32_8x16Em+0xa6>
 7e4:	21 15       	cp	r18, r1
 7e6:	31 05       	cpc	r19, r1
 7e8:	41 05       	cpc	r20, r1
 7ea:	51 05       	cpc	r21, r1
 7ec:	61 f0       	breq	.+24     	; 0x806 <_ZN9RAYLIDLCD14print_U32_8x16Em+0xa6>
			{
				I2C_send(temp%10+0x30);
 7ee:	ca 01       	movw	r24, r20
 7f0:	b9 01       	movw	r22, r18
 7f2:	a5 01       	movw	r20, r10
 7f4:	94 01       	movw	r18, r8
 7f6:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 7fa:	86 2f       	mov	r24, r22
 7fc:	80 5d       	subi	r24, 0xD0	; 208
 7fe:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
				t=1;
 802:	10 2f       	mov	r17, r16
 804:	0c c0       	rjmp	.+24     	; 0x81e <_ZN9RAYLIDLCD14print_U32_8x16Em+0xbe>
			}
			else if(t==1)
 806:	11 30       	cpi	r17, 0x01	; 1
 808:	51 f4       	brne	.+20     	; 0x81e <_ZN9RAYLIDLCD14print_U32_8x16Em+0xbe>
			{
				I2C_send(temp%10+0x30);
 80a:	ca 01       	movw	r24, r20
 80c:	b9 01       	movw	r22, r18
 80e:	a5 01       	movw	r20, r10
 810:	94 01       	movw	r18, r8
 812:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 816:	86 2f       	mov	r24, r22
 818:	80 5d       	subi	r24, 0xD0	; 208
 81a:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	{
		I2C_send(0x30);
	}
	else
	{
		for(i=1000000000;i>=1;i=i/10)
 81e:	c7 01       	movw	r24, r14
 820:	b6 01       	movw	r22, r12
 822:	a5 01       	movw	r20, r10
 824:	94 01       	movw	r18, r8
 826:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 82a:	69 01       	movw	r12, r18
 82c:	7a 01       	movw	r14, r20
 82e:	21 97       	sbiw	r28, 0x01	; 1
 830:	89 f6       	brne	.-94     	; 0x7d4 <_ZN9RAYLIDLCD14print_U32_8x16Em+0x74>
			{
				I2C_send(temp%10+0x30);
			}
		}
	}
	I2C_send(0x00);
 832:	80 e0       	ldi	r24, 0x00	; 0
 834:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 838:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 83c:	df 91       	pop	r29
 83e:	cf 91       	pop	r28
 840:	1f 91       	pop	r17
 842:	0f 91       	pop	r16
 844:	ff 90       	pop	r15
 846:	ef 90       	pop	r14
 848:	df 90       	pop	r13
 84a:	cf 90       	pop	r12
 84c:	bf 90       	pop	r11
 84e:	af 90       	pop	r10
 850:	9f 90       	pop	r9
 852:	8f 90       	pop	r8
 854:	7f 90       	pop	r7
 856:	6f 90       	pop	r6
 858:	5f 90       	pop	r5
 85a:	4f 90       	pop	r4
 85c:	08 95       	ret

0000085e <_ZN9RAYLIDLCD16print_U32_5x7_xyEhhm>:
/***********************************************************************
*函数原型:print_U32_5x7_xy(U8 x,U8 y,U32 n)
*在指定位置显示长整型变量n
***********************************************************************/
void RAYLIDLCD::print_U32_5x7_xy(U8 x,U8 y,U32 n)
{
 85e:	4f 92       	push	r4
 860:	5f 92       	push	r5
 862:	6f 92       	push	r6
 864:	7f 92       	push	r7
 866:	8f 92       	push	r8
 868:	9f 92       	push	r9
 86a:	af 92       	push	r10
 86c:	bf 92       	push	r11
 86e:	cf 92       	push	r12
 870:	df 92       	push	r13
 872:	ef 92       	push	r14
 874:	ff 92       	push	r15
 876:	0f 93       	push	r16
 878:	1f 93       	push	r17
 87a:	cf 93       	push	r28
 87c:	df 93       	push	r29
 87e:	c6 2f       	mov	r28, r22
 880:	c4 2e       	mov	r12, r20
 882:	28 01       	movw	r4, r16
 884:	39 01       	movw	r6, r18
	U32 i,temp;
	U8 t=0;
	I2C_start();
 886:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 88a:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x20);
 88e:	80 e2       	ldi	r24, 0x20	; 32
 890:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 894:	8c 2f       	mov	r24, r28
 896:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 89a:	8c 2d       	mov	r24, r12
 89c:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(0x24);
 8a0:	84 e2       	ldi	r24, 0x24	; 36
 8a2:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	if(n==0)
 8a6:	41 14       	cp	r4, r1
 8a8:	51 04       	cpc	r5, r1
 8aa:	61 04       	cpc	r6, r1
 8ac:	71 04       	cpc	r7, r1
 8ae:	21 f4       	brne	.+8      	; 0x8b8 <_ZN9RAYLIDLCD16print_U32_5x7_xyEhhm+0x5a>
	{
		I2C_send(0x30);
 8b0:	80 e3       	ldi	r24, 0x30	; 48
 8b2:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
 8b6:	47 c0       	rjmp	.+142    	; 0x946 <__stack+0x47>
	I2C_to_write();
	I2C_send(0x20);
	I2C_send(x);
	I2C_send(y);
	I2C_send(0x24);
	if(n==0)
 8b8:	ca e0       	ldi	r28, 0x0A	; 10
 8ba:	d0 e0       	ldi	r29, 0x00	; 0
 8bc:	10 e0       	ldi	r17, 0x00	; 0
 8be:	0f 2e       	mov	r0, r31
 8c0:	f0 e0       	ldi	r31, 0x00	; 0
 8c2:	cf 2e       	mov	r12, r31
 8c4:	fa ec       	ldi	r31, 0xCA	; 202
 8c6:	df 2e       	mov	r13, r31
 8c8:	fa e9       	ldi	r31, 0x9A	; 154
 8ca:	ef 2e       	mov	r14, r31
 8cc:	fb e3       	ldi	r31, 0x3B	; 59
 8ce:	ff 2e       	mov	r15, r31
 8d0:	f0 2d       	mov	r31, r0
				I2C_send(temp%10+0x30);
				t=1;
			}
			else if(t==1)
			{
				I2C_send(temp%10+0x30);
 8d2:	0f 2e       	mov	r0, r31
 8d4:	fa e0       	ldi	r31, 0x0A	; 10
 8d6:	8f 2e       	mov	r8, r31
 8d8:	f0 e0       	ldi	r31, 0x00	; 0
 8da:	9f 2e       	mov	r9, r31
 8dc:	f0 e0       	ldi	r31, 0x00	; 0
 8de:	af 2e       	mov	r10, r31
 8e0:	f0 e0       	ldi	r31, 0x00	; 0
 8e2:	bf 2e       	mov	r11, r31
 8e4:	f0 2d       	mov	r31, r0
		{
			temp=n/i;
			if(t==0&&temp)
			{
				I2C_send(temp%10+0x30);
				t=1;
 8e6:	01 e0       	ldi	r16, 0x01	; 1
	}
	else
	{
		for(i=1000000000;i>=1;i=i/10)
		{
			temp=n/i;
 8e8:	c3 01       	movw	r24, r6
 8ea:	b2 01       	movw	r22, r4
 8ec:	a7 01       	movw	r20, r14
 8ee:	96 01       	movw	r18, r12
 8f0:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
			if(t==0&&temp)
 8f4:	11 23       	and	r17, r17
 8f6:	89 f4       	brne	.+34     	; 0x91a <__stack+0x1b>
 8f8:	21 15       	cp	r18, r1
 8fa:	31 05       	cpc	r19, r1
 8fc:	41 05       	cpc	r20, r1
 8fe:	51 05       	cpc	r21, r1
 900:	61 f0       	breq	.+24     	; 0x91a <__stack+0x1b>
			{
				I2C_send(temp%10+0x30);
 902:	ca 01       	movw	r24, r20
 904:	b9 01       	movw	r22, r18
 906:	a5 01       	movw	r20, r10
 908:	94 01       	movw	r18, r8
 90a:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 90e:	86 2f       	mov	r24, r22
 910:	80 5d       	subi	r24, 0xD0	; 208
 912:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
				t=1;
 916:	10 2f       	mov	r17, r16
 918:	0c c0       	rjmp	.+24     	; 0x932 <__stack+0x33>
			}
			else if(t==1)
 91a:	11 30       	cpi	r17, 0x01	; 1
 91c:	51 f4       	brne	.+20     	; 0x932 <__stack+0x33>
			{
				I2C_send(temp%10+0x30);
 91e:	ca 01       	movw	r24, r20
 920:	b9 01       	movw	r22, r18
 922:	a5 01       	movw	r20, r10
 924:	94 01       	movw	r18, r8
 926:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 92a:	86 2f       	mov	r24, r22
 92c:	80 5d       	subi	r24, 0xD0	; 208
 92e:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	{
		I2C_send(0x30);
	}
	else
	{
		for(i=1000000000;i>=1;i=i/10)
 932:	c7 01       	movw	r24, r14
 934:	b6 01       	movw	r22, r12
 936:	a5 01       	movw	r20, r10
 938:	94 01       	movw	r18, r8
 93a:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 93e:	69 01       	movw	r12, r18
 940:	7a 01       	movw	r14, r20
 942:	21 97       	sbiw	r28, 0x01	; 1
 944:	89 f6       	brne	.-94     	; 0x8e8 <_ZN9RAYLIDLCD16print_U32_5x7_xyEhhm+0x8a>
			{
				I2C_send(temp%10+0x30);
			}
		}
	}
	I2C_send(0x00);
 946:	80 e0       	ldi	r24, 0x00	; 0
 948:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 94c:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 950:	df 91       	pop	r29
 952:	cf 91       	pop	r28
 954:	1f 91       	pop	r17
 956:	0f 91       	pop	r16
 958:	ff 90       	pop	r15
 95a:	ef 90       	pop	r14
 95c:	df 90       	pop	r13
 95e:	cf 90       	pop	r12
 960:	bf 90       	pop	r11
 962:	af 90       	pop	r10
 964:	9f 90       	pop	r9
 966:	8f 90       	pop	r8
 968:	7f 90       	pop	r7
 96a:	6f 90       	pop	r6
 96c:	5f 90       	pop	r5
 96e:	4f 90       	pop	r4
 970:	08 95       	ret

00000972 <_ZN9RAYLIDLCD17print_U32_6x12_xyEhhm>:
/***********************************************************************
*函数原型:print_U32_6x12_xy(U8 x,U8 y,U32 n)
*在指定位置显示长整型变量n
***********************************************************************/
void RAYLIDLCD::print_U32_6x12_xy(U8 x,U8 y,U32 n)
{
 972:	4f 92       	push	r4
 974:	5f 92       	push	r5
 976:	6f 92       	push	r6
 978:	7f 92       	push	r7
 97a:	8f 92       	push	r8
 97c:	9f 92       	push	r9
 97e:	af 92       	push	r10
 980:	bf 92       	push	r11
 982:	cf 92       	push	r12
 984:	df 92       	push	r13
 986:	ef 92       	push	r14
 988:	ff 92       	push	r15
 98a:	0f 93       	push	r16
 98c:	1f 93       	push	r17
 98e:	cf 93       	push	r28
 990:	df 93       	push	r29
 992:	c6 2f       	mov	r28, r22
 994:	c4 2e       	mov	r12, r20
 996:	28 01       	movw	r4, r16
 998:	39 01       	movw	r6, r18
	U32 i,temp;
	U8 t=0;
	I2C_start();
 99a:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 99e:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x20);
 9a2:	80 e2       	ldi	r24, 0x20	; 32
 9a4:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 9a8:	8c 2f       	mov	r24, r28
 9aa:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 9ae:	8c 2d       	mov	r24, r12
 9b0:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(0x25);
 9b4:	85 e2       	ldi	r24, 0x25	; 37
 9b6:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	if(n==0)
 9ba:	41 14       	cp	r4, r1
 9bc:	51 04       	cpc	r5, r1
 9be:	61 04       	cpc	r6, r1
 9c0:	71 04       	cpc	r7, r1
 9c2:	21 f4       	brne	.+8      	; 0x9cc <_ZN9RAYLIDLCD17print_U32_6x12_xyEhhm+0x5a>
	{
		I2C_send(0x30);
 9c4:	80 e3       	ldi	r24, 0x30	; 48
 9c6:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
 9ca:	47 c0       	rjmp	.+142    	; 0xa5a <_ZN9RAYLIDLCD17print_U32_6x12_xyEhhm+0xe8>
	I2C_to_write();
	I2C_send(0x20);
	I2C_send(x);
	I2C_send(y);
	I2C_send(0x25);
	if(n==0)
 9cc:	ca e0       	ldi	r28, 0x0A	; 10
 9ce:	d0 e0       	ldi	r29, 0x00	; 0
 9d0:	10 e0       	ldi	r17, 0x00	; 0
 9d2:	0f 2e       	mov	r0, r31
 9d4:	f0 e0       	ldi	r31, 0x00	; 0
 9d6:	cf 2e       	mov	r12, r31
 9d8:	fa ec       	ldi	r31, 0xCA	; 202
 9da:	df 2e       	mov	r13, r31
 9dc:	fa e9       	ldi	r31, 0x9A	; 154
 9de:	ef 2e       	mov	r14, r31
 9e0:	fb e3       	ldi	r31, 0x3B	; 59
 9e2:	ff 2e       	mov	r15, r31
 9e4:	f0 2d       	mov	r31, r0
				I2C_send(temp%10+0x30);
				t=1;
			}
			else if(t==1)
			{
				I2C_send(temp%10+0x30);
 9e6:	0f 2e       	mov	r0, r31
 9e8:	fa e0       	ldi	r31, 0x0A	; 10
 9ea:	8f 2e       	mov	r8, r31
 9ec:	f0 e0       	ldi	r31, 0x00	; 0
 9ee:	9f 2e       	mov	r9, r31
 9f0:	f0 e0       	ldi	r31, 0x00	; 0
 9f2:	af 2e       	mov	r10, r31
 9f4:	f0 e0       	ldi	r31, 0x00	; 0
 9f6:	bf 2e       	mov	r11, r31
 9f8:	f0 2d       	mov	r31, r0
		{
			temp=n/i;
			if(t==0&&temp)
			{
				I2C_send(temp%10+0x30);
				t=1;
 9fa:	01 e0       	ldi	r16, 0x01	; 1
	}
	else
	{
		for(i=1000000000;i>=1;i=i/10)
		{
			temp=n/i;
 9fc:	c3 01       	movw	r24, r6
 9fe:	b2 01       	movw	r22, r4
 a00:	a7 01       	movw	r20, r14
 a02:	96 01       	movw	r18, r12
 a04:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
			if(t==0&&temp)
 a08:	11 23       	and	r17, r17
 a0a:	89 f4       	brne	.+34     	; 0xa2e <_ZN9RAYLIDLCD17print_U32_6x12_xyEhhm+0xbc>
 a0c:	21 15       	cp	r18, r1
 a0e:	31 05       	cpc	r19, r1
 a10:	41 05       	cpc	r20, r1
 a12:	51 05       	cpc	r21, r1
 a14:	61 f0       	breq	.+24     	; 0xa2e <_ZN9RAYLIDLCD17print_U32_6x12_xyEhhm+0xbc>
			{
				I2C_send(temp%10+0x30);
 a16:	ca 01       	movw	r24, r20
 a18:	b9 01       	movw	r22, r18
 a1a:	a5 01       	movw	r20, r10
 a1c:	94 01       	movw	r18, r8
 a1e:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 a22:	86 2f       	mov	r24, r22
 a24:	80 5d       	subi	r24, 0xD0	; 208
 a26:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
				t=1;
 a2a:	10 2f       	mov	r17, r16
 a2c:	0c c0       	rjmp	.+24     	; 0xa46 <_ZN9RAYLIDLCD17print_U32_6x12_xyEhhm+0xd4>
			}
			else if(t==1)
 a2e:	11 30       	cpi	r17, 0x01	; 1
 a30:	51 f4       	brne	.+20     	; 0xa46 <_ZN9RAYLIDLCD17print_U32_6x12_xyEhhm+0xd4>
			{
				I2C_send(temp%10+0x30);
 a32:	ca 01       	movw	r24, r20
 a34:	b9 01       	movw	r22, r18
 a36:	a5 01       	movw	r20, r10
 a38:	94 01       	movw	r18, r8
 a3a:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 a3e:	86 2f       	mov	r24, r22
 a40:	80 5d       	subi	r24, 0xD0	; 208
 a42:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	{
		I2C_send(0x30);
	}
	else
	{
		for(i=1000000000;i>=1;i=i/10)
 a46:	c7 01       	movw	r24, r14
 a48:	b6 01       	movw	r22, r12
 a4a:	a5 01       	movw	r20, r10
 a4c:	94 01       	movw	r18, r8
 a4e:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 a52:	69 01       	movw	r12, r18
 a54:	7a 01       	movw	r14, r20
 a56:	21 97       	sbiw	r28, 0x01	; 1
 a58:	89 f6       	brne	.-94     	; 0x9fc <_ZN9RAYLIDLCD17print_U32_6x12_xyEhhm+0x8a>
			{
				I2C_send(temp%10+0x30);
			}
		}
	}
	I2C_send(0x00);
 a5a:	80 e0       	ldi	r24, 0x00	; 0
 a5c:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 a60:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 a64:	df 91       	pop	r29
 a66:	cf 91       	pop	r28
 a68:	1f 91       	pop	r17
 a6a:	0f 91       	pop	r16
 a6c:	ff 90       	pop	r15
 a6e:	ef 90       	pop	r14
 a70:	df 90       	pop	r13
 a72:	cf 90       	pop	r12
 a74:	bf 90       	pop	r11
 a76:	af 90       	pop	r10
 a78:	9f 90       	pop	r9
 a7a:	8f 90       	pop	r8
 a7c:	7f 90       	pop	r7
 a7e:	6f 90       	pop	r6
 a80:	5f 90       	pop	r5
 a82:	4f 90       	pop	r4
 a84:	08 95       	ret

00000a86 <_ZN9RAYLIDLCD17print_U32_8x16_xyEhhm>:
/***********************************************************************
*函数原型:print_U32_8x16_xy(U8 x,U8 y,U32 n)
*在指定位置显示长整型变量n
***********************************************************************/
void RAYLIDLCD::print_U32_8x16_xy(U8 x,U8 y,U32 n)
{
 a86:	4f 92       	push	r4
 a88:	5f 92       	push	r5
 a8a:	6f 92       	push	r6
 a8c:	7f 92       	push	r7
 a8e:	8f 92       	push	r8
 a90:	9f 92       	push	r9
 a92:	af 92       	push	r10
 a94:	bf 92       	push	r11
 a96:	cf 92       	push	r12
 a98:	df 92       	push	r13
 a9a:	ef 92       	push	r14
 a9c:	ff 92       	push	r15
 a9e:	0f 93       	push	r16
 aa0:	1f 93       	push	r17
 aa2:	cf 93       	push	r28
 aa4:	df 93       	push	r29
 aa6:	c6 2f       	mov	r28, r22
 aa8:	c4 2e       	mov	r12, r20
 aaa:	28 01       	movw	r4, r16
 aac:	39 01       	movw	r6, r18
	U32 i,temp;
	U8 t=0;
	I2C_start();
 aae:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 ab2:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x20);
 ab6:	80 e2       	ldi	r24, 0x20	; 32
 ab8:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 abc:	8c 2f       	mov	r24, r28
 abe:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 ac2:	8c 2d       	mov	r24, r12
 ac4:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(0x26);
 ac8:	86 e2       	ldi	r24, 0x26	; 38
 aca:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	if(n==0)
 ace:	41 14       	cp	r4, r1
 ad0:	51 04       	cpc	r5, r1
 ad2:	61 04       	cpc	r6, r1
 ad4:	71 04       	cpc	r7, r1
 ad6:	21 f4       	brne	.+8      	; 0xae0 <_ZN9RAYLIDLCD17print_U32_8x16_xyEhhm+0x5a>
	{
		I2C_send(0x30);
 ad8:	80 e3       	ldi	r24, 0x30	; 48
 ada:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
 ade:	47 c0       	rjmp	.+142    	; 0xb6e <_ZN9RAYLIDLCD17print_U32_8x16_xyEhhm+0xe8>
	I2C_to_write();
	I2C_send(0x20);
	I2C_send(x);
	I2C_send(y);
	I2C_send(0x26);
	if(n==0)
 ae0:	ca e0       	ldi	r28, 0x0A	; 10
 ae2:	d0 e0       	ldi	r29, 0x00	; 0
 ae4:	10 e0       	ldi	r17, 0x00	; 0
 ae6:	0f 2e       	mov	r0, r31
 ae8:	f0 e0       	ldi	r31, 0x00	; 0
 aea:	cf 2e       	mov	r12, r31
 aec:	fa ec       	ldi	r31, 0xCA	; 202
 aee:	df 2e       	mov	r13, r31
 af0:	fa e9       	ldi	r31, 0x9A	; 154
 af2:	ef 2e       	mov	r14, r31
 af4:	fb e3       	ldi	r31, 0x3B	; 59
 af6:	ff 2e       	mov	r15, r31
 af8:	f0 2d       	mov	r31, r0
				I2C_send(temp%10+0x30);
				t=1;
			}
			else if(t==1)
			{
				I2C_send(temp%10+0x30);
 afa:	0f 2e       	mov	r0, r31
 afc:	fa e0       	ldi	r31, 0x0A	; 10
 afe:	8f 2e       	mov	r8, r31
 b00:	f0 e0       	ldi	r31, 0x00	; 0
 b02:	9f 2e       	mov	r9, r31
 b04:	f0 e0       	ldi	r31, 0x00	; 0
 b06:	af 2e       	mov	r10, r31
 b08:	f0 e0       	ldi	r31, 0x00	; 0
 b0a:	bf 2e       	mov	r11, r31
 b0c:	f0 2d       	mov	r31, r0
		{
			temp=n/i;
			if(t==0&&temp)
			{
				I2C_send(temp%10+0x30);
				t=1;
 b0e:	01 e0       	ldi	r16, 0x01	; 1
	}
	else
	{
		for(i=1000000000;i>=1;i=i/10)
		{
			temp=n/i;
 b10:	c3 01       	movw	r24, r6
 b12:	b2 01       	movw	r22, r4
 b14:	a7 01       	movw	r20, r14
 b16:	96 01       	movw	r18, r12
 b18:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
			if(t==0&&temp)
 b1c:	11 23       	and	r17, r17
 b1e:	89 f4       	brne	.+34     	; 0xb42 <_ZN9RAYLIDLCD17print_U32_8x16_xyEhhm+0xbc>
 b20:	21 15       	cp	r18, r1
 b22:	31 05       	cpc	r19, r1
 b24:	41 05       	cpc	r20, r1
 b26:	51 05       	cpc	r21, r1
 b28:	61 f0       	breq	.+24     	; 0xb42 <_ZN9RAYLIDLCD17print_U32_8x16_xyEhhm+0xbc>
			{
				I2C_send(temp%10+0x30);
 b2a:	ca 01       	movw	r24, r20
 b2c:	b9 01       	movw	r22, r18
 b2e:	a5 01       	movw	r20, r10
 b30:	94 01       	movw	r18, r8
 b32:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 b36:	86 2f       	mov	r24, r22
 b38:	80 5d       	subi	r24, 0xD0	; 208
 b3a:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
				t=1;
 b3e:	10 2f       	mov	r17, r16
 b40:	0c c0       	rjmp	.+24     	; 0xb5a <_ZN9RAYLIDLCD17print_U32_8x16_xyEhhm+0xd4>
			}
			else if(t==1)
 b42:	11 30       	cpi	r17, 0x01	; 1
 b44:	51 f4       	brne	.+20     	; 0xb5a <_ZN9RAYLIDLCD17print_U32_8x16_xyEhhm+0xd4>
			{
				I2C_send(temp%10+0x30);
 b46:	ca 01       	movw	r24, r20
 b48:	b9 01       	movw	r22, r18
 b4a:	a5 01       	movw	r20, r10
 b4c:	94 01       	movw	r18, r8
 b4e:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 b52:	86 2f       	mov	r24, r22
 b54:	80 5d       	subi	r24, 0xD0	; 208
 b56:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	{
		I2C_send(0x30);
	}
	else
	{
		for(i=1000000000;i>=1;i=i/10)
 b5a:	c7 01       	movw	r24, r14
 b5c:	b6 01       	movw	r22, r12
 b5e:	a5 01       	movw	r20, r10
 b60:	94 01       	movw	r18, r8
 b62:	0e 94 89 07 	call	0xf12	; 0xf12 <__udivmodsi4>
 b66:	69 01       	movw	r12, r18
 b68:	7a 01       	movw	r14, r20
 b6a:	21 97       	sbiw	r28, 0x01	; 1
 b6c:	89 f6       	brne	.-94     	; 0xb10 <_ZN9RAYLIDLCD17print_U32_8x16_xyEhhm+0x8a>
			{
				I2C_send(temp%10+0x30);
			}
		}
	}
	I2C_send(0x00);
 b6e:	80 e0       	ldi	r24, 0x00	; 0
 b70:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 b74:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 b78:	df 91       	pop	r29
 b7a:	cf 91       	pop	r28
 b7c:	1f 91       	pop	r17
 b7e:	0f 91       	pop	r16
 b80:	ff 90       	pop	r15
 b82:	ef 90       	pop	r14
 b84:	df 90       	pop	r13
 b86:	cf 90       	pop	r12
 b88:	bf 90       	pop	r11
 b8a:	af 90       	pop	r10
 b8c:	9f 90       	pop	r9
 b8e:	8f 90       	pop	r8
 b90:	7f 90       	pop	r7
 b92:	6f 90       	pop	r6
 b94:	5f 90       	pop	r5
 b96:	4f 90       	pop	r4
 b98:	08 95       	ret

00000b9a <_ZN9RAYLIDLCD15print_string_12EPKc>:
/***********************************************************************
*函数原型:print_string_12(CCHAR *ptr)
*在当前位置显示字符串*ptr,支持全角和半角混合显示
***********************************************************************/
void RAYLIDLCD::print_string_12(CCHAR *ptr)
{
 b9a:	cf 93       	push	r28
 b9c:	df 93       	push	r29
 b9e:	eb 01       	movw	r28, r22
	I2C_start();
 ba0:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 ba4:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x27);
 ba8:	87 e2       	ldi	r24, 0x27	; 39
 baa:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	while(*ptr!='\0')
 bae:	88 81       	ld	r24, Y
 bb0:	88 23       	and	r24, r24
 bb2:	31 f0       	breq	.+12     	; 0xbc0 <_ZN9RAYLIDLCD15print_string_12EPKc+0x26>

/***********************************************************************
*函数原型:print_string_12(CCHAR *ptr)
*在当前位置显示字符串*ptr,支持全角和半角混合显示
***********************************************************************/
void RAYLIDLCD::print_string_12(CCHAR *ptr)
 bb4:	21 96       	adiw	r28, 0x01	; 1
	I2C_start();
	I2C_to_write();
	I2C_send(0x27);
	while(*ptr!='\0')
	{
		I2C_send(*ptr++);
 bb6:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
void RAYLIDLCD::print_string_12(CCHAR *ptr)
{
	I2C_start();
	I2C_to_write();
	I2C_send(0x27);
	while(*ptr!='\0')
 bba:	89 91       	ld	r24, Y+
 bbc:	88 23       	and	r24, r24
 bbe:	d9 f7       	brne	.-10     	; 0xbb6 <_ZN9RAYLIDLCD15print_string_12EPKc+0x1c>
	{
		I2C_send(*ptr++);
	}
	I2C_send(0x00);
 bc0:	80 e0       	ldi	r24, 0x00	; 0
 bc2:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 bc6:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 bca:	df 91       	pop	r29
 bcc:	cf 91       	pop	r28
 bce:	08 95       	ret

00000bd0 <_ZN9RAYLIDLCD15print_string_16EPKc>:
/***********************************************************************
*函数原型:print_string_16(CCHAR *ptr)
*在当前位置显示字符串*ptr,支持全角和半角混合显示
***********************************************************************/
void RAYLIDLCD::print_string_16(CCHAR *ptr)
{
 bd0:	cf 93       	push	r28
 bd2:	df 93       	push	r29
 bd4:	eb 01       	movw	r28, r22
	I2C_start();
 bd6:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 bda:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x28);
 bde:	88 e2       	ldi	r24, 0x28	; 40
 be0:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	while(*ptr!='\0')
 be4:	88 81       	ld	r24, Y
 be6:	88 23       	and	r24, r24
 be8:	31 f0       	breq	.+12     	; 0xbf6 <_ZN9RAYLIDLCD15print_string_16EPKc+0x26>
}
/***********************************************************************
*函数原型:print_string_16(CCHAR *ptr)
*在当前位置显示字符串*ptr,支持全角和半角混合显示
***********************************************************************/
void RAYLIDLCD::print_string_16(CCHAR *ptr)
 bea:	21 96       	adiw	r28, 0x01	; 1
	I2C_start();
	I2C_to_write();
	I2C_send(0x28);
	while(*ptr!='\0')
	{
		I2C_send(*ptr++);
 bec:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
void RAYLIDLCD::print_string_16(CCHAR *ptr)
{
	I2C_start();
	I2C_to_write();
	I2C_send(0x28);
	while(*ptr!='\0')
 bf0:	89 91       	ld	r24, Y+
 bf2:	88 23       	and	r24, r24
 bf4:	d9 f7       	brne	.-10     	; 0xbec <_ZN9RAYLIDLCD15print_string_16EPKc+0x1c>
	{
		I2C_send(*ptr++);
	}
	I2C_send(0x00);
 bf6:	80 e0       	ldi	r24, 0x00	; 0
 bf8:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 bfc:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 c00:	df 91       	pop	r29
 c02:	cf 91       	pop	r28
 c04:	08 95       	ret

00000c06 <_ZN9RAYLIDLCD18print_string_12_xyEhhPKc>:
/***********************************************************************
*函数原型:print_string_12_xy(U8 x,U8 y,CCHAR *ptr)
*在指定位置显示字符串*ptr,支持全角和半角混合显示
***********************************************************************/
void RAYLIDLCD::print_string_12_xy(U8 x,U8 y,CCHAR *ptr)
{
 c06:	0f 93       	push	r16
 c08:	1f 93       	push	r17
 c0a:	cf 93       	push	r28
 c0c:	df 93       	push	r29
 c0e:	06 2f       	mov	r16, r22
 c10:	14 2f       	mov	r17, r20
 c12:	e9 01       	movw	r28, r18
	I2C_start();
 c14:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 c18:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x20);
 c1c:	80 e2       	ldi	r24, 0x20	; 32
 c1e:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 c22:	80 2f       	mov	r24, r16
 c24:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 c28:	81 2f       	mov	r24, r17
 c2a:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(0x27);
 c2e:	87 e2       	ldi	r24, 0x27	; 39
 c30:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	while(*ptr!='\0')
 c34:	88 81       	ld	r24, Y
 c36:	88 23       	and	r24, r24
 c38:	31 f0       	breq	.+12     	; 0xc46 <_ZN9RAYLIDLCD18print_string_12_xyEhhPKc+0x40>

/***********************************************************************
*函数原型:print_string_12_xy(U8 x,U8 y,CCHAR *ptr)
*在指定位置显示字符串*ptr,支持全角和半角混合显示
***********************************************************************/
void RAYLIDLCD::print_string_12_xy(U8 x,U8 y,CCHAR *ptr)
 c3a:	21 96       	adiw	r28, 0x01	; 1
	I2C_send(x);
	I2C_send(y);
	I2C_send(0x27);
	while(*ptr!='\0')
	{
		I2C_send(*ptr++);
 c3c:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_to_write();
	I2C_send(0x20);
	I2C_send(x);
	I2C_send(y);
	I2C_send(0x27);
	while(*ptr!='\0')
 c40:	89 91       	ld	r24, Y+
 c42:	88 23       	and	r24, r24
 c44:	d9 f7       	brne	.-10     	; 0xc3c <_ZN9RAYLIDLCD18print_string_12_xyEhhPKc+0x36>
	{
		I2C_send(*ptr++);
	}
	I2C_send(0x00);
 c46:	80 e0       	ldi	r24, 0x00	; 0
 c48:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 c4c:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 c50:	df 91       	pop	r29
 c52:	cf 91       	pop	r28
 c54:	1f 91       	pop	r17
 c56:	0f 91       	pop	r16
 c58:	08 95       	ret

00000c5a <_ZN9RAYLIDLCD18print_string_16_xyEhhPKc>:
/***********************************************************************
*函数原型:print_string_16_xy(U8 x,U8 y,CCHAR *ptr)
*在指定位置显示字符串*ptr,支持全角和半角混合显示
***********************************************************************/
void RAYLIDLCD::print_string_16_xy(U8 x,U8 y,CCHAR *ptr)
{
 c5a:	0f 93       	push	r16
 c5c:	1f 93       	push	r17
 c5e:	cf 93       	push	r28
 c60:	df 93       	push	r29
 c62:	06 2f       	mov	r16, r22
 c64:	14 2f       	mov	r17, r20
 c66:	e9 01       	movw	r28, r18
	I2C_start();
 c68:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 c6c:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x20);
 c70:	80 e2       	ldi	r24, 0x20	; 32
 c72:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 c76:	80 2f       	mov	r24, r16
 c78:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 c7c:	81 2f       	mov	r24, r17
 c7e:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(0x28);
 c82:	88 e2       	ldi	r24, 0x28	; 40
 c84:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	while(*ptr!='\0')
 c88:	88 81       	ld	r24, Y
 c8a:	88 23       	and	r24, r24
 c8c:	31 f0       	breq	.+12     	; 0xc9a <_ZN9RAYLIDLCD18print_string_16_xyEhhPKc+0x40>
}
/***********************************************************************
*函数原型:print_string_16_xy(U8 x,U8 y,CCHAR *ptr)
*在指定位置显示字符串*ptr,支持全角和半角混合显示
***********************************************************************/
void RAYLIDLCD::print_string_16_xy(U8 x,U8 y,CCHAR *ptr)
 c8e:	21 96       	adiw	r28, 0x01	; 1
	I2C_send(x);
	I2C_send(y);
	I2C_send(0x28);
	while(*ptr!='\0')
	{
		I2C_send(*ptr++);
 c90:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_to_write();
	I2C_send(0x20);
	I2C_send(x);
	I2C_send(y);
	I2C_send(0x28);
	while(*ptr!='\0')
 c94:	89 91       	ld	r24, Y+
 c96:	88 23       	and	r24, r24
 c98:	d9 f7       	brne	.-10     	; 0xc90 <_ZN9RAYLIDLCD18print_string_16_xyEhhPKc+0x36>
	{
		I2C_send(*ptr++);
	}
	I2C_send(0x00);
 c9a:	80 e0       	ldi	r24, 0x00	; 0
 c9c:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 ca0:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 ca4:	df 91       	pop	r29
 ca6:	cf 91       	pop	r28
 ca8:	1f 91       	pop	r17
 caa:	0f 91       	pop	r16
 cac:	08 95       	ret

00000cae <_ZN9RAYLIDLCD16print_string_5x7EPKc>:
/***********************************************************************
*函数原型:print_string_5x7(CCHAR *ptr)
*在当前位置显示字符串*ptr,支持5*7ASCII
***********************************************************************/
void RAYLIDLCD::print_string_5x7(CCHAR *ptr)
{
 cae:	cf 93       	push	r28
 cb0:	df 93       	push	r29
 cb2:	eb 01       	movw	r28, r22
	I2C_start();
 cb4:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 cb8:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x24);
 cbc:	84 e2       	ldi	r24, 0x24	; 36
 cbe:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	while(*ptr!='\0')
 cc2:	88 81       	ld	r24, Y
 cc4:	88 23       	and	r24, r24
 cc6:	31 f0       	breq	.+12     	; 0xcd4 <_ZN9RAYLIDLCD16print_string_5x7EPKc+0x26>

/***********************************************************************
*函数原型:print_string_5x7(CCHAR *ptr)
*在当前位置显示字符串*ptr,支持5*7ASCII
***********************************************************************/
void RAYLIDLCD::print_string_5x7(CCHAR *ptr)
 cc8:	21 96       	adiw	r28, 0x01	; 1
	I2C_start();
	I2C_to_write();
	I2C_send(0x24);
	while(*ptr!='\0')
	{
		I2C_send(*ptr++);
 cca:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
void RAYLIDLCD::print_string_5x7(CCHAR *ptr)
{
	I2C_start();
	I2C_to_write();
	I2C_send(0x24);
	while(*ptr!='\0')
 cce:	89 91       	ld	r24, Y+
 cd0:	88 23       	and	r24, r24
 cd2:	d9 f7       	brne	.-10     	; 0xcca <_ZN9RAYLIDLCD16print_string_5x7EPKc+0x1c>
	{
		I2C_send(*ptr++);
	}
	I2C_send(0x00);
 cd4:	80 e0       	ldi	r24, 0x00	; 0
 cd6:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 cda:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 cde:	df 91       	pop	r29
 ce0:	cf 91       	pop	r28
 ce2:	08 95       	ret

00000ce4 <_ZN9RAYLIDLCD17print_string_6x12EPKc>:
/***********************************************************************
*函数原型:print_string_6x12(CCHAR *ptr)
*在当前位置显示字符串*ptr,支持6*12ASCII
***********************************************************************/
void RAYLIDLCD::print_string_6x12(CCHAR *ptr)
{
 ce4:	cf 93       	push	r28
 ce6:	df 93       	push	r29
 ce8:	eb 01       	movw	r28, r22
	I2C_start();
 cea:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 cee:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x25);
 cf2:	85 e2       	ldi	r24, 0x25	; 37
 cf4:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	while(*ptr!='\0')
 cf8:	88 81       	ld	r24, Y
 cfa:	88 23       	and	r24, r24
 cfc:	31 f0       	breq	.+12     	; 0xd0a <_ZN9RAYLIDLCD17print_string_6x12EPKc+0x26>

/***********************************************************************
*函数原型:print_string_6x12(CCHAR *ptr)
*在当前位置显示字符串*ptr,支持6*12ASCII
***********************************************************************/
void RAYLIDLCD::print_string_6x12(CCHAR *ptr)
 cfe:	21 96       	adiw	r28, 0x01	; 1
	I2C_start();
	I2C_to_write();
	I2C_send(0x25);
	while(*ptr!='\0')
	{
		I2C_send(*ptr++);
 d00:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
void RAYLIDLCD::print_string_6x12(CCHAR *ptr)
{
	I2C_start();
	I2C_to_write();
	I2C_send(0x25);
	while(*ptr!='\0')
 d04:	89 91       	ld	r24, Y+
 d06:	88 23       	and	r24, r24
 d08:	d9 f7       	brne	.-10     	; 0xd00 <_ZN9RAYLIDLCD17print_string_6x12EPKc+0x1c>
	{
		I2C_send(*ptr++);
	}
	I2C_send(0x00);
 d0a:	80 e0       	ldi	r24, 0x00	; 0
 d0c:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 d10:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 d14:	df 91       	pop	r29
 d16:	cf 91       	pop	r28
 d18:	08 95       	ret

00000d1a <_ZN9RAYLIDLCD17print_string_8x16EPKc>:
/***********************************************************************
*函数原型:print_string_8x16(CCHAR *ptr)
*在当前位置显示字符串*ptr,支持8*16ASCII
***********************************************************************/
void RAYLIDLCD::print_string_8x16(CCHAR *ptr)
{
 d1a:	cf 93       	push	r28
 d1c:	df 93       	push	r29
 d1e:	eb 01       	movw	r28, r22
	I2C_start();
 d20:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 d24:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x26);
 d28:	86 e2       	ldi	r24, 0x26	; 38
 d2a:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	while(*ptr!='\0')
 d2e:	88 81       	ld	r24, Y
 d30:	88 23       	and	r24, r24
 d32:	31 f0       	breq	.+12     	; 0xd40 <_ZN9RAYLIDLCD17print_string_8x16EPKc+0x26>

/***********************************************************************
*函数原型:print_string_8x16(CCHAR *ptr)
*在当前位置显示字符串*ptr,支持8*16ASCII
***********************************************************************/
void RAYLIDLCD::print_string_8x16(CCHAR *ptr)
 d34:	21 96       	adiw	r28, 0x01	; 1
	I2C_start();
	I2C_to_write();
	I2C_send(0x26);
	while(*ptr!='\0')
	{
		I2C_send(*ptr++);
 d36:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
void RAYLIDLCD::print_string_8x16(CCHAR *ptr)
{
	I2C_start();
	I2C_to_write();
	I2C_send(0x26);
	while(*ptr!='\0')
 d3a:	89 91       	ld	r24, Y+
 d3c:	88 23       	and	r24, r24
 d3e:	d9 f7       	brne	.-10     	; 0xd36 <_ZN9RAYLIDLCD17print_string_8x16EPKc+0x1c>
	{
		I2C_send(*ptr++);
	}
	I2C_send(0x00);
 d40:	80 e0       	ldi	r24, 0x00	; 0
 d42:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 d46:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 d4a:	df 91       	pop	r29
 d4c:	cf 91       	pop	r28
 d4e:	08 95       	ret

00000d50 <_ZN9RAYLIDLCD19print_string_5x7_xyEhhPKc>:
/***********************************************************************
*函数原型:print_string_5x7_xy(U8 x,U8 y,CCHAR *ptr)
*在指定位置显示字符串*ptr,支持5*7ASCII
***********************************************************************/
void RAYLIDLCD::print_string_5x7_xy(U8 x,U8 y,CCHAR *ptr)
{
 d50:	0f 93       	push	r16
 d52:	1f 93       	push	r17
 d54:	cf 93       	push	r28
 d56:	df 93       	push	r29
 d58:	06 2f       	mov	r16, r22
 d5a:	14 2f       	mov	r17, r20
 d5c:	e9 01       	movw	r28, r18
	I2C_start();
 d5e:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 d62:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x20);
 d66:	80 e2       	ldi	r24, 0x20	; 32
 d68:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 d6c:	80 2f       	mov	r24, r16
 d6e:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 d72:	81 2f       	mov	r24, r17
 d74:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(0x24);
 d78:	84 e2       	ldi	r24, 0x24	; 36
 d7a:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	while(*ptr!='\0')
 d7e:	88 81       	ld	r24, Y
 d80:	88 23       	and	r24, r24
 d82:	31 f0       	breq	.+12     	; 0xd90 <_ZN9RAYLIDLCD19print_string_5x7_xyEhhPKc+0x40>

/***********************************************************************
*函数原型:print_string_5x7_xy(U8 x,U8 y,CCHAR *ptr)
*在指定位置显示字符串*ptr,支持5*7ASCII
***********************************************************************/
void RAYLIDLCD::print_string_5x7_xy(U8 x,U8 y,CCHAR *ptr)
 d84:	21 96       	adiw	r28, 0x01	; 1
	I2C_send(x);
	I2C_send(y);
	I2C_send(0x24);
	while(*ptr!='\0')
	{
		I2C_send(*ptr++);
 d86:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_to_write();
	I2C_send(0x20);
	I2C_send(x);
	I2C_send(y);
	I2C_send(0x24);
	while(*ptr!='\0')
 d8a:	89 91       	ld	r24, Y+
 d8c:	88 23       	and	r24, r24
 d8e:	d9 f7       	brne	.-10     	; 0xd86 <_ZN9RAYLIDLCD19print_string_5x7_xyEhhPKc+0x36>
	{
		I2C_send(*ptr++);
	}
	I2C_send(0x00);
 d90:	80 e0       	ldi	r24, 0x00	; 0
 d92:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 d96:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 d9a:	df 91       	pop	r29
 d9c:	cf 91       	pop	r28
 d9e:	1f 91       	pop	r17
 da0:	0f 91       	pop	r16
 da2:	08 95       	ret

00000da4 <_ZN9RAYLIDLCD20print_string_6x12_xyEhhPKc>:
/***********************************************************************
*函数原型:print_string_6x12_xy(U8 x,U8 y,CCHAR *ptr)
*在指定位置显示字符串*ptr,支持6*12ASCII
***********************************************************************/
void RAYLIDLCD::print_string_6x12_xy(U8 x,U8 y,CCHAR *ptr)
{
 da4:	0f 93       	push	r16
 da6:	1f 93       	push	r17
 da8:	cf 93       	push	r28
 daa:	df 93       	push	r29
 dac:	06 2f       	mov	r16, r22
 dae:	14 2f       	mov	r17, r20
 db0:	e9 01       	movw	r28, r18
	I2C_start();
 db2:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 db6:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x20);
 dba:	80 e2       	ldi	r24, 0x20	; 32
 dbc:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 dc0:	80 2f       	mov	r24, r16
 dc2:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 dc6:	81 2f       	mov	r24, r17
 dc8:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(0x25);
 dcc:	85 e2       	ldi	r24, 0x25	; 37
 dce:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	while(*ptr!='\0')
 dd2:	88 81       	ld	r24, Y
 dd4:	88 23       	and	r24, r24
 dd6:	31 f0       	breq	.+12     	; 0xde4 <_ZN9RAYLIDLCD20print_string_6x12_xyEhhPKc+0x40>

/***********************************************************************
*函数原型:print_string_6x12_xy(U8 x,U8 y,CCHAR *ptr)
*在指定位置显示字符串*ptr,支持6*12ASCII
***********************************************************************/
void RAYLIDLCD::print_string_6x12_xy(U8 x,U8 y,CCHAR *ptr)
 dd8:	21 96       	adiw	r28, 0x01	; 1
	I2C_send(x);
	I2C_send(y);
	I2C_send(0x25);
	while(*ptr!='\0')
	{
		I2C_send(*ptr++);
 dda:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_to_write();
	I2C_send(0x20);
	I2C_send(x);
	I2C_send(y);
	I2C_send(0x25);
	while(*ptr!='\0')
 dde:	89 91       	ld	r24, Y+
 de0:	88 23       	and	r24, r24
 de2:	d9 f7       	brne	.-10     	; 0xdda <_ZN9RAYLIDLCD20print_string_6x12_xyEhhPKc+0x36>
	{
		I2C_send(*ptr++);
	}
	I2C_send(0x00);
 de4:	80 e0       	ldi	r24, 0x00	; 0
 de6:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 dea:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 dee:	df 91       	pop	r29
 df0:	cf 91       	pop	r28
 df2:	1f 91       	pop	r17
 df4:	0f 91       	pop	r16
 df6:	08 95       	ret

00000df8 <_ZN9RAYLIDLCD20print_string_8x16_xyEhhPKc>:
/***********************************************************************
*函数原型:print_string_8x16_xy(U8 x,U8 y,CCHAR *ptr)
*在指定位置显示字符串*ptr,支持8*16ASCII
***********************************************************************/
void RAYLIDLCD::print_string_8x16_xy(U8 x,U8 y,CCHAR *ptr)
{
 df8:	0f 93       	push	r16
 dfa:	1f 93       	push	r17
 dfc:	cf 93       	push	r28
 dfe:	df 93       	push	r29
 e00:	06 2f       	mov	r16, r22
 e02:	14 2f       	mov	r17, r20
 e04:	e9 01       	movw	r28, r18
	I2C_start();
 e06:	0e 94 37 07 	call	0xe6e	; 0xe6e <I2C_start>
	I2C_to_write();
 e0a:	0e 94 56 07 	call	0xeac	; 0xeac <I2C_to_write>
	I2C_send(0x20);
 e0e:	80 e2       	ldi	r24, 0x20	; 32
 e10:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(x);
 e14:	80 2f       	mov	r24, r16
 e16:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(y);
 e1a:	81 2f       	mov	r24, r17
 e1c:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_send(0x26);
 e20:	86 e2       	ldi	r24, 0x26	; 38
 e22:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	while(*ptr!='\0')
 e26:	88 81       	ld	r24, Y
 e28:	88 23       	and	r24, r24
 e2a:	31 f0       	breq	.+12     	; 0xe38 <_ZN9RAYLIDLCD20print_string_8x16_xyEhhPKc+0x40>

/***********************************************************************
*函数原型:print_string_8x16_xy(U8 x,U8 y,CCHAR *ptr)
*在指定位置显示字符串*ptr,支持8*16ASCII
***********************************************************************/
void RAYLIDLCD::print_string_8x16_xy(U8 x,U8 y,CCHAR *ptr)
 e2c:	21 96       	adiw	r28, 0x01	; 1
	I2C_send(x);
	I2C_send(y);
	I2C_send(0x26);
	while(*ptr!='\0')
	{
		I2C_send(*ptr++);
 e2e:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_to_write();
	I2C_send(0x20);
	I2C_send(x);
	I2C_send(y);
	I2C_send(0x26);
	while(*ptr!='\0')
 e32:	89 91       	ld	r24, Y+
 e34:	88 23       	and	r24, r24
 e36:	d9 f7       	brne	.-10     	; 0xe2e <_ZN9RAYLIDLCD20print_string_8x16_xyEhhPKc+0x36>
	{
		I2C_send(*ptr++);
	}
	I2C_send(0x00);
 e38:	80 e0       	ldi	r24, 0x00	; 0
 e3a:	0e 94 69 07 	call	0xed2	; 0xed2 <I2C_send>
	I2C_stop();
 e3e:	0e 94 50 07 	call	0xea0	; 0xea0 <I2C_stop>
}
 e42:	df 91       	pop	r29
 e44:	cf 91       	pop	r28
 e46:	1f 91       	pop	r17
 e48:	0f 91       	pop	r16
 e4a:	08 95       	ret

00000e4c <I2C_init>:
#include <avr/signal.h>


void I2C_init(void)
{
	TWBR = 0x80; // set the bit rate
 e4c:	80 e8       	ldi	r24, 0x80	; 128
 e4e:	80 93 b8 00 	sts	0x00B8, r24
	TWAR = 0x00; // set the slave address
 e52:	10 92 ba 00 	sts	0x00BA, r1
	TWSR |= 0x00; // Set the division factor
 e56:	e9 eb       	ldi	r30, 0xB9	; 185
 e58:	f0 e0       	ldi	r31, 0x00	; 0
 e5a:	80 81       	ld	r24, Z
 e5c:	80 83       	st	Z, r24
	TWCR = 0X00;
 e5e:	10 92 bc 00 	sts	0x00BC, r1
	
	DDRC=DDRC&0XF7;//PC3 check LCD BUSY
 e62:	3b 98       	cbi	0x07, 3	; 7
	PORTC=PORTC|0X08;
 e64:	43 9a       	sbi	0x08, 3	; 8
}
 e66:	08 95       	ret

00000e68 <busy>:

void busy(void)
{
	while(PINC&0x08); //Check LCD busy
 e68:	33 99       	sbic	0x06, 3	; 6
 e6a:	fe cf       	rjmp	.-4      	; 0xe68 <busy>
}
 e6c:	08 95       	ret

00000e6e <I2C_start>:
// Arbitration becomes host and sends START signal
// return value: 1 for success, 0 for failure
uint8_t I2C_start(void)
{
	busy();
 e6e:	0e 94 34 07 	call	0xe68	; 0xe68 <busy>
	TWCR|=(1<<TWINT)|(1<<TWEN)|(1<<TWSTA);
 e72:	ec eb       	ldi	r30, 0xBC	; 188
 e74:	f0 e0       	ldi	r31, 0x00	; 0
 e76:	80 81       	ld	r24, Z
 e78:	84 6a       	ori	r24, 0xA4	; 164
 e7a:	80 83       	st	Z, r24
	while(!(TWCR & (1<<TWINT)));
 e7c:	80 81       	ld	r24, Z
 e7e:	88 23       	and	r24, r24
 e80:	ec f7       	brge	.-6      	; 0xe7c <I2C_start+0xe>
	if(((TWSR & 0xf8)!=0x08) && ((TWSR & 0xf8)!=0x10))
 e82:	80 91 b9 00 	lds	r24, 0x00B9
 e86:	88 7f       	andi	r24, 0xF8	; 248
 e88:	88 30       	cpi	r24, 0x08	; 8
 e8a:	41 f0       	breq	.+16     	; 0xe9c <I2C_start+0x2e>
 e8c:	90 91 b9 00 	lds	r25, 0x00B9
 e90:	98 7f       	andi	r25, 0xF8	; 248
{
	while(PINC&0x08); //Check LCD busy
}
// Arbitration becomes host and sends START signal
// return value: 1 for success, 0 for failure
uint8_t I2C_start(void)
 e92:	81 e0       	ldi	r24, 0x01	; 1
 e94:	90 31       	cpi	r25, 0x10	; 16
 e96:	19 f0       	breq	.+6      	; 0xe9e <I2C_start+0x30>
 e98:	80 e0       	ldi	r24, 0x00	; 0
 e9a:	08 95       	ret
	busy();
	TWCR|=(1<<TWINT)|(1<<TWEN)|(1<<TWSTA);
	while(!(TWCR & (1<<TWINT)));
	if(((TWSR & 0xf8)!=0x08) && ((TWSR & 0xf8)!=0x10))
	return 0;
	return 1;
 e9c:	81 e0       	ldi	r24, 0x01	; 1
}
 e9e:	08 95       	ret

00000ea0 <I2C_stop>:

// stop communication and send STOP signal)`
void I2C_stop(void)
{
	TWCR|=(1<<TWINT)|(1<<TWEN)|(1<<TWSTO);
 ea0:	ec eb       	ldi	r30, 0xBC	; 188
 ea2:	f0 e0       	ldi	r31, 0x00	; 0
 ea4:	80 81       	ld	r24, Z
 ea6:	84 69       	ori	r24, 0x94	; 148
 ea8:	80 83       	st	Z, r24
}
 eaa:	08 95       	ret

00000eac <I2C_to_write>:

// Issued from the machine address and write command, that is, SLA + W, into the MT mode
// return value: 1 for success, 0 for failure
uint8_t I2C_to_write(void)
{
	TWDR=0;
 eac:	10 92 bb 00 	sts	0x00BB, r1
	TWCR=(TWCR&0X0F)|(1<<TWINT)|(1<<TWEN);
 eb0:	ec eb       	ldi	r30, 0xBC	; 188
 eb2:	f0 e0       	ldi	r31, 0x00	; 0
 eb4:	80 81       	ld	r24, Z
 eb6:	8b 70       	andi	r24, 0x0B	; 11
 eb8:	84 68       	ori	r24, 0x84	; 132
 eba:	80 83       	st	Z, r24
	while(!(TWCR &(1<<TWINT)));
 ebc:	80 81       	ld	r24, Z
 ebe:	88 23       	and	r24, r24
 ec0:	ec f7       	brge	.-6      	; 0xebc <I2C_to_write+0x10>
	if((TWSR & 0xf8)!=0x18)
 ec2:	90 91 b9 00 	lds	r25, 0x00B9
 ec6:	98 7f       	andi	r25, 0xF8	; 248
	return 0;
 ec8:	81 e0       	ldi	r24, 0x01	; 1
 eca:	98 31       	cpi	r25, 0x18	; 24
 ecc:	09 f0       	breq	.+2      	; 0xed0 <I2C_to_write+0x24>
 ece:	80 e0       	ldi	r24, 0x00	; 0
	return 1;
}
 ed0:	08 95       	ret

00000ed2 <I2C_send>:

// send data to the slave
// return value: 0 for failure, 1 for ACK, 2 for NOT ACK
uint8_t I2C_send(uint8_t data)
{
 ed2:	cf 93       	push	r28
 ed4:	c8 2f       	mov	r28, r24
	busy();
 ed6:	0e 94 34 07 	call	0xe68	; 0xe68 <busy>
	TWDR=data;
 eda:	c0 93 bb 00 	sts	0x00BB, r28
	TWCR=(TWCR&0X0F)|(1<<TWINT)|(1<<TWEN);
 ede:	ec eb       	ldi	r30, 0xBC	; 188
 ee0:	f0 e0       	ldi	r31, 0x00	; 0
 ee2:	80 81       	ld	r24, Z
 ee4:	8b 70       	andi	r24, 0x0B	; 11
 ee6:	84 68       	ori	r24, 0x84	; 132
 ee8:	80 83       	st	Z, r24
	while(!(TWCR & (1<<TWINT)));
 eea:	80 81       	ld	r24, Z
 eec:	88 23       	and	r24, r24
 eee:	ec f7       	brge	.-6      	; 0xeea <I2C_send+0x18>
	if((TWSR & 0xf8)==0x28)
 ef0:	80 91 b9 00 	lds	r24, 0x00B9
 ef4:	88 7f       	andi	r24, 0xF8	; 248
 ef6:	88 32       	cpi	r24, 0x28	; 40
 ef8:	39 f0       	breq	.+14     	; 0xf08 <I2C_send+0x36>
	return 1;
	else if((TWSR & 0xf8)==0x30)
 efa:	80 91 b9 00 	lds	r24, 0x00B9
 efe:	88 7f       	andi	r24, 0xF8	; 248
 f00:	80 33       	cpi	r24, 0x30	; 48
 f02:	21 f4       	brne	.+8      	; 0xf0c <I2C_send+0x3a>
	return 2;
 f04:	82 e0       	ldi	r24, 0x02	; 2
 f06:	03 c0       	rjmp	.+6      	; 0xf0e <I2C_send+0x3c>
	busy();
	TWDR=data;
	TWCR=(TWCR&0X0F)|(1<<TWINT)|(1<<TWEN);
	while(!(TWCR & (1<<TWINT)));
	if((TWSR & 0xf8)==0x28)
	return 1;
 f08:	81 e0       	ldi	r24, 0x01	; 1
 f0a:	01 c0       	rjmp	.+2      	; 0xf0e <I2C_send+0x3c>
	else if((TWSR & 0xf8)==0x30)
	return 2;
	return 0;
 f0c:	80 e0       	ldi	r24, 0x00	; 0
}
 f0e:	cf 91       	pop	r28
 f10:	08 95       	ret

00000f12 <__udivmodsi4>:
 f12:	a1 e2       	ldi	r26, 0x21	; 33
 f14:	1a 2e       	mov	r1, r26
 f16:	aa 1b       	sub	r26, r26
 f18:	bb 1b       	sub	r27, r27
 f1a:	fd 01       	movw	r30, r26
 f1c:	0d c0       	rjmp	.+26     	; 0xf38 <__udivmodsi4_ep>

00000f1e <__udivmodsi4_loop>:
 f1e:	aa 1f       	adc	r26, r26
 f20:	bb 1f       	adc	r27, r27
 f22:	ee 1f       	adc	r30, r30
 f24:	ff 1f       	adc	r31, r31
 f26:	a2 17       	cp	r26, r18
 f28:	b3 07       	cpc	r27, r19
 f2a:	e4 07       	cpc	r30, r20
 f2c:	f5 07       	cpc	r31, r21
 f2e:	20 f0       	brcs	.+8      	; 0xf38 <__udivmodsi4_ep>
 f30:	a2 1b       	sub	r26, r18
 f32:	b3 0b       	sbc	r27, r19
 f34:	e4 0b       	sbc	r30, r20
 f36:	f5 0b       	sbc	r31, r21

00000f38 <__udivmodsi4_ep>:
 f38:	66 1f       	adc	r22, r22
 f3a:	77 1f       	adc	r23, r23
 f3c:	88 1f       	adc	r24, r24
 f3e:	99 1f       	adc	r25, r25
 f40:	1a 94       	dec	r1
 f42:	69 f7       	brne	.-38     	; 0xf1e <__udivmodsi4_loop>
 f44:	60 95       	com	r22
 f46:	70 95       	com	r23
 f48:	80 95       	com	r24
 f4a:	90 95       	com	r25
 f4c:	9b 01       	movw	r18, r22
 f4e:	ac 01       	movw	r20, r24
 f50:	bd 01       	movw	r22, r26
 f52:	cf 01       	movw	r24, r30
 f54:	08 95       	ret

00000f56 <_exit>:
 f56:	f8 94       	cli

00000f58 <__stop_program>:
 f58:	ff cf       	rjmp	.-2      	; 0xf58 <__stop_program>
